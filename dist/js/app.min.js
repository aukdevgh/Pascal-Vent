/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/assets/js/app.js":
/*!******************************!*\
  !*** ./src/assets/js/app.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_modal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/_modal.js */ \"./src/assets/js/components/_modal.js\");\n/* harmony import */ var _components_burger_menu_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/_burger-menu.js */ \"./src/assets/js/components/_burger-menu.js\");\n/* harmony import */ var _components_service_desc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/_service-desc.js */ \"./src/assets/js/components/_service-desc.js\");\n/* harmony import */ var _components_header_on_scroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/_header-on-scroll.js */ \"./src/assets/js/components/_header-on-scroll.js\");\n/* harmony import */ var _components_form_validation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/_form-validation.js */ \"./src/assets/js/components/_form-validation.js\");\n/* harmony import */ var _modules_flickity_slider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/flickity-slider.js */ \"./src/assets/js/modules/flickity-slider.js\");\n/* harmony import */ var _components_slider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/_slider.js */ \"./src/assets/js/components/_slider.js\");\ndocument.addEventListener('touchstart', onTouchStart, { passive: true });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/app.js?");

/***/ }),

/***/ "./src/assets/js/components/_burger-menu.js":
/*!**************************************************!*\
  !*** ./src/assets/js/components/_burger-menu.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst headerNav = document.querySelector('.header__nav');\r\nconst menuBtn = document.querySelector('.header__menu-btn');\r\n\r\nmenuBtn.addEventListener('click', () => {\r\n    headerNav.classList.toggle('header__nav--mobile');\r\n});\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/components/_burger-menu.js?");

/***/ }),

/***/ "./src/assets/js/components/_form-validation.js":
/*!******************************************************!*\
  !*** ./src/assets/js/components/_form-validation.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst namePattern = /^([А-Я]{1}[а-яё]{1,23}|[A-Z]{1}[a-z]{1,23})$/g;\r\nconst phonePattern = /^((\\+7)[\\- ]?)?(\\(?\\d\\)?[\\- ]?){10}$/g;\r\n\r\nconst requestForm = document.querySelector('.request__form');\r\nconst requestFormNameInput = requestForm.querySelector('.name');\r\nconst requestFormPhoneInput = requestForm.querySelector('.phone');\r\nconst requestFormSubmitBtn = requestForm.querySelector('.form__submit');\r\n\r\nconst requestFormSuccess = new Set();\r\nrequestFormSubmitBtn.disabled = true;\r\n\r\nrequestFormNameInput.addEventListener('input', (e) => {\r\n    checker(\r\n        requestFormSuccess,\r\n        requestFormSubmitBtn,\r\n        e.target.value,\r\n        requestFormNameInput,\r\n        namePattern,\r\n        'Не корректное имя'\r\n    );\r\n});\r\n\r\nrequestFormPhoneInput.addEventListener('input', (e) => {\r\n    checker(\r\n        requestFormSuccess,\r\n        requestFormSubmitBtn,\r\n        e.target.value,\r\n        requestFormPhoneInput,\r\n        phonePattern,\r\n        'Номер не корректный'\r\n    );\r\n});\r\n\r\nconst footerForm = document.querySelector('.footer__form');\r\nconst footerFormNameInput = footerForm.querySelector('.name');\r\nconst footerFormPhoneInput = footerForm.querySelector('.phone');\r\nconst footerFormSubmitBtn = footerForm.querySelector('.form__submit');\r\n\r\nconst footerFormSuccess = new Set();\r\nfooterFormSubmitBtn.disabled = true;\r\n\r\nfooterFormNameInput.addEventListener('input', (e) => {\r\n    checker(\r\n        footerFormSuccess,\r\n        footerFormSubmitBtn,\r\n        e.target.value,\r\n        footerFormNameInput,\r\n        namePattern,\r\n        'Не корректное имя'\r\n    );\r\n});\r\n\r\nfooterFormPhoneInput.addEventListener('input', (e) => {\r\n    checker(\r\n        footerFormSuccess,\r\n        footerFormSubmitBtn,\r\n        e.target.value,\r\n        footerFormPhoneInput,\r\n        phonePattern,\r\n        'Номер не корректный'\r\n    );\r\n});\r\n\r\nconst modalForm = document.querySelector('.modal__form');\r\nconst modalFormNameInput = modalForm.querySelector('.name');\r\nconst modalFormPhoneInput = modalForm.querySelector('.phone');\r\nconst modalFormSubmitBtn = modalForm.querySelector('.form__submit');\r\n\r\nconst modalFormSuccess = new Set();\r\nmodalFormSubmitBtn.disabled = true;\r\n\r\nmodalFormNameInput.addEventListener('input', (e) => {\r\n    checker(\r\n        modalFormSuccess,\r\n        modalFormSubmitBtn,\r\n        e.target.value,\r\n        modalFormNameInput,\r\n        namePattern,\r\n        'Не корректное имя'\r\n    );\r\n});\r\n\r\nmodalFormPhoneInput.addEventListener('input', (e) => {\r\n    checker(\r\n        modalFormSuccess,\r\n        modalFormSubmitBtn,\r\n        e.target.value,\r\n        modalFormPhoneInput,\r\n        phonePattern,\r\n        'Номер не корректный'\r\n    );\r\n});\r\n\r\nfunction clearError(inputField) {\r\n    const err = inputField.closest('.form__group').querySelector('.error');\r\n    if (err) {\r\n        err.remove();\r\n    }\r\n}\r\n\r\nfunction showError(field, errorText) {\r\n    const errorElement = document.createElement('small');\r\n    errorElement.classList.add('error');\r\n    errorElement.innerText = errorText;\r\n    field.closest('.form__group').appendChild(errorElement);\r\n}\r\n\r\nfunction changeSubmitStatus(success, submitBtn) {\r\n    if (success.size == 2) {\r\n        submitBtn.disabled = false;\r\n    } else {\r\n        submitBtn.disabled = true;\r\n    }\r\n}\r\n\r\nfunction checker(success, submitBtn, value, input, pattern, msg) {\r\n    clearError(input);\r\n\r\n    const isValid = pattern.test(value);\r\n\r\n    if (isValid) {\r\n        success.add(input);\r\n    } else {\r\n        success.delete(input);\r\n        showError(input, msg);\r\n    }\r\n\r\n    changeSubmitStatus(success, submitBtn);\r\n}\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/components/_form-validation.js?");

/***/ }),

/***/ "./src/assets/js/components/_header-on-scroll.js":
/*!*******************************************************!*\
  !*** ./src/assets/js/components/_header-on-scroll.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst header = document.querySelector('#header');\r\nconst headerInner = header.querySelector('.header__inner');\r\nconst scrollWatcher = document.createElement('div');\r\n\r\nscrollWatcher.setAttribute('data-scroll-watcher', '');\r\nheader.before(scrollWatcher);\r\n\r\nconst navObserver = new IntersectionObserver((entries) => {\r\n    headerInner.classList.toggle('fixing', !entries[0].isIntersecting);\r\n});\r\n\r\nnavObserver.observe(scrollWatcher);\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/components/_header-on-scroll.js?");

/***/ }),

/***/ "./src/assets/js/components/_modal.js":
/*!********************************************!*\
  !*** ./src/assets/js/components/_modal.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst callBackModal = document.querySelector('.modal--call-back');\r\nconst callBackBtn = document.querySelector('#callBackBtn');\r\nconst callBackCloseBtn = document.querySelector('#callBackCloseBtn');\r\n\r\ncallBackBtn.addEventListener('click', () => {\r\n    callBackModal.classList.toggle('modal--show');\r\n    callBackCloseBtn.focus();\r\n});\r\n\r\ncallBackCloseBtn.addEventListener('click', () => {\r\n    callBackModal.classList.toggle('modal--show');\r\n});\r\n\r\nconst requestModal = document.querySelector('.modal--request');\r\nconst requestModalClose = document.querySelector('#requestModalClose');\r\nconst leaveRequestBtn = document.querySelector('#leaveRequestBtn');\r\nconst fillOutRequestBtn = document.querySelector('#fillOutRequestBtn');\r\n\r\nleaveRequestBtn.addEventListener('click', () => {\r\n    requestModal.classList.toggle('modal--show');\r\n    requestModalClose.focus();\r\n});\r\n\r\nfillOutRequestBtn.addEventListener('click', () => {\r\n    requestModal.classList.toggle('modal--show');\r\n    requestModalClose.focus();\r\n});\r\n\r\nrequestModalClose.addEventListener('click', () => {\r\n    requestModal.classList.toggle('modal--show');\r\n});\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/components/_modal.js?");

/***/ }),

/***/ "./src/assets/js/components/_service-desc.js":
/*!***************************************************!*\
  !*** ./src/assets/js/components/_service-desc.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst vent = document.querySelector('#vent-desc');\r\nconst cond = document.querySelector('#cond-desc');\r\nconst ventBtn = document.querySelector('#vent-btn');\r\nconst condBtn = document.querySelector('#cond-btn');\r\n\r\nventBtn.addEventListener('click', () => {\r\n    cond.classList.remove('active');\r\n    condBtn.classList.remove('active');\r\n    vent.classList.add('active');\r\n    ventBtn.classList.add('active');\r\n    console.log(cond, vent);\r\n});\r\n\r\ncondBtn.addEventListener('click', () => {\r\n    vent.classList.remove('active');\r\n    ventBtn.classList.remove('active');\r\n    cond.classList.add('active');\r\n    condBtn.classList.add('active');\r\n    console.log(cond, vent);\r\n});\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/components/_service-desc.js?");

/***/ }),

/***/ "./src/assets/js/components/_slider.js":
/*!*********************************************!*\
  !*** ./src/assets/js/components/_slider.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst portfolio = document.querySelector('.portfolio__slider');\r\nconst portfolioPrevBtn = document.querySelector('.portfolio__prev-btn');\r\nconst portfolioNextBtn = document.querySelector('.portfolio__next-btn');\r\n\r\nconst reviews = document.querySelector('.reviews__slider');\r\nconst reviewsPrevBtn = document.querySelector('.reviews__prev-btn');\r\nconst reviewsNextBtn = document.querySelector('.reviews__next-btn');\r\n\r\nconst portfolioSlider = new Flickity(portfolio, {\r\n    // options\r\n    cellAlign: 'left',\r\n    pageDots: false,\r\n    imagesLoaded: true,\r\n    lazyLoad: true,\r\n    percentPosition: false,\r\n    prevNextButtons: false,\r\n});\r\n\r\nportfolioSlider.on('change', portfolioSlider.reposition);\r\n\r\nportfolioPrevBtn.disabled = portfolioSlider.selectedIndex == 0;\r\n\r\nportfolioPrevBtn.addEventListener('click', () =>\r\n    prev(portfolioSlider, portfolioPrevBtn, portfolioNextBtn)\r\n);\r\n\r\nportfolioNextBtn.addEventListener('click', () =>\r\n    next(portfolioSlider, portfolioPrevBtn, portfolioNextBtn)\r\n);\r\n\r\nconst reviewsSlider = new Flickity(reviews, {\r\n    // options\r\n    cellAlign: 'left',\r\n    pageDots: false,\r\n    imagesLoaded: true,\r\n    lazyLoad: true,\r\n    percentPosition: false,\r\n    prevNextButtons: false,\r\n});\r\n\r\nreviewsPrevBtn.disabled = reviewsSlider.selectedIndex == 0;\r\n\r\nreviewsPrevBtn.addEventListener('click', () =>\r\n    prev(reviewsSlider, reviewsPrevBtn, reviewsNextBtn)\r\n);\r\n\r\nreviewsNextBtn.addEventListener('click', () =>\r\n    next(reviewsSlider, reviewsPrevBtn, reviewsNextBtn)\r\n);\r\n\r\nfunction prev(slider, preBtn, nextBtn) {\r\n    slider.previous();\r\n\r\n    nextBtn.disabled = false;\r\n\r\n    preBtn.disabled = slider.selectedIndex == 0;\r\n}\r\n\r\nfunction next(slider, preBtn, nextBtn) {\r\n    slider.next();\r\n\r\n    preBtn.disabled = false;\r\n\r\n    const lastIndex = slider.slides.length - 1;\r\n    nextBtn.disabled = slider.selectedIndex == lastIndex;\r\n}\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/components/_slider.js?");

/***/ }),

/***/ "./src/assets/js/modules/flickity-slider.js":
/*!**************************************************!*\
  !*** ./src/assets/js/modules/flickity-slider.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/*!\r\n * Flickity PACKAGED v2.3.0\r\n * Touch, responsive, flickable carousels\r\n *\r\n * Licensed GPLv3 for open source use\r\n * or Flickity Commercial License for commercial use\r\n *\r\n * https://flickity.metafizzy.co\r\n * Copyright 2015-2021 Metafizzy\r\n */\r\n\r\n/**\r\n * Bridget makes jQuery widgets\r\n * v2.0.1\r\n * MIT license\r\n */\r\n\r\n/* jshint browser: true, strict: true, undef: true, unused: true */\r\n\r\n(function (window, factory) {\r\n    // universal module definition\r\n    /*jshint strict: false */ /* globals define, module, require */\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('jquery-bridget/jquery-bridget', ['jquery'], function (jQuery) {\r\n            return factory(window, jQuery);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(window, require('jquery'));\r\n    } else {\r\n        // browser global\r\n        window.jQueryBridget = factory(window, window.jQuery);\r\n    }\r\n})(window, function factory(window, jQuery) {\r\n    'use strict';\r\n\r\n    // ----- utils ----- //\r\n\r\n    var arraySlice = Array.prototype.slice;\r\n\r\n    // helper function for logging errors\r\n    // $.error breaks jQuery chaining\r\n    var console = window.console;\r\n    var logError =\r\n        typeof console == 'undefined'\r\n            ? function () {}\r\n            : function (message) {\r\n                  console.error(message);\r\n              };\r\n\r\n    // ----- jQueryBridget ----- //\r\n\r\n    function jQueryBridget(namespace, PluginClass, $) {\r\n        $ = $ || jQuery || window.jQuery;\r\n        if (!$) {\r\n            return;\r\n        }\r\n\r\n        // add option method -> $().plugin('option', {...})\r\n        if (!PluginClass.prototype.option) {\r\n            // option setter\r\n            PluginClass.prototype.option = function (opts) {\r\n                // bail out if not an object\r\n                if (!$.isPlainObject(opts)) {\r\n                    return;\r\n                }\r\n                this.options = $.extend(true, this.options, opts);\r\n            };\r\n        }\r\n\r\n        // make jQuery plugin\r\n        $.fn[namespace] = function (arg0 /*, arg1 */) {\r\n            if (typeof arg0 == 'string') {\r\n                // method call $().plugin( 'methodName', { options } )\r\n                // shift arguments by 1\r\n                var args = arraySlice.call(arguments, 1);\r\n                return methodCall(this, arg0, args);\r\n            }\r\n            // just $().plugin({ options })\r\n            plainCall(this, arg0);\r\n            return this;\r\n        };\r\n\r\n        // $().plugin('methodName')\r\n        function methodCall($elems, methodName, args) {\r\n            var returnValue;\r\n            var pluginMethodStr = '$().' + namespace + '(\"' + methodName + '\")';\r\n\r\n            $elems.each(function (i, elem) {\r\n                // get instance\r\n                var instance = $.data(elem, namespace);\r\n                if (!instance) {\r\n                    logError(\r\n                        namespace +\r\n                            ' not initialized. Cannot call methods, i.e. ' +\r\n                            pluginMethodStr\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                var method = instance[methodName];\r\n                if (!method || methodName.charAt(0) == '_') {\r\n                    logError(pluginMethodStr + ' is not a valid method');\r\n                    return;\r\n                }\r\n\r\n                // apply method, get return value\r\n                var value = method.apply(instance, args);\r\n                // set return value if value is returned, use only first value\r\n                returnValue = returnValue === undefined ? value : returnValue;\r\n            });\r\n\r\n            return returnValue !== undefined ? returnValue : $elems;\r\n        }\r\n\r\n        function plainCall($elems, options) {\r\n            $elems.each(function (i, elem) {\r\n                var instance = $.data(elem, namespace);\r\n                if (instance) {\r\n                    // set options & init\r\n                    instance.option(options);\r\n                    instance._init();\r\n                } else {\r\n                    // initialize new instance\r\n                    instance = new PluginClass(elem, options);\r\n                    $.data(elem, namespace, instance);\r\n                }\r\n            });\r\n        }\r\n\r\n        updateJQuery($);\r\n    }\r\n\r\n    // ----- updateJQuery ----- //\r\n\r\n    // set $.bridget for v1 backwards compatibility\r\n    function updateJQuery($) {\r\n        if (!$ || ($ && $.bridget)) {\r\n            return;\r\n        }\r\n        $.bridget = jQueryBridget;\r\n    }\r\n\r\n    updateJQuery(jQuery || window.jQuery);\r\n\r\n    // -----  ----- //\r\n\r\n    return jQueryBridget;\r\n});\r\n\r\n/**\r\n * EvEmitter v1.1.0\r\n * Lil' event emitter\r\n * MIT License\r\n */\r\n\r\n/* jshint unused: true, undef: true, strict: true */\r\n\r\n(function (global, factory) {\r\n    // universal module definition\r\n    /* jshint strict: false */ /* globals define, module, window */\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD - RequireJS\r\n        define('ev-emitter/ev-emitter', factory);\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS - Browserify, Webpack\r\n        module.exports = factory();\r\n    } else {\r\n        // Browser globals\r\n        global.EvEmitter = factory();\r\n    }\r\n})(typeof window != 'undefined' ? window : undefined, function () {\r\n    function EvEmitter() {}\r\n\r\n    var proto = EvEmitter.prototype;\r\n\r\n    proto.on = function (eventName, listener) {\r\n        if (!eventName || !listener) {\r\n            return;\r\n        }\r\n        // set events hash\r\n        var events = (this._events = this._events || {});\r\n        // set listeners array\r\n        var listeners = (events[eventName] = events[eventName] || []);\r\n        // only add once\r\n        if (listeners.indexOf(listener) == -1) {\r\n            listeners.push(listener);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    proto.once = function (eventName, listener) {\r\n        if (!eventName || !listener) {\r\n            return;\r\n        }\r\n        // add event\r\n        this.on(eventName, listener);\r\n        // set once flag\r\n        // set onceEvents hash\r\n        var onceEvents = (this._onceEvents = this._onceEvents || {});\r\n        // set onceListeners object\r\n        var onceListeners = (onceEvents[eventName] =\r\n            onceEvents[eventName] || {});\r\n        // set flag\r\n        onceListeners[listener] = true;\r\n\r\n        return this;\r\n    };\r\n\r\n    proto.off = function (eventName, listener) {\r\n        var listeners = this._events && this._events[eventName];\r\n        if (!listeners || !listeners.length) {\r\n            return;\r\n        }\r\n        var index = listeners.indexOf(listener);\r\n        if (index != -1) {\r\n            listeners.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    proto.emitEvent = function (eventName, args) {\r\n        var listeners = this._events && this._events[eventName];\r\n        if (!listeners || !listeners.length) {\r\n            return;\r\n        }\r\n        // copy over to avoid interference if .off() in listener\r\n        listeners = listeners.slice(0);\r\n        args = args || [];\r\n        // once stuff\r\n        var onceListeners = this._onceEvents && this._onceEvents[eventName];\r\n\r\n        for (var i = 0; i < listeners.length; i++) {\r\n            var listener = listeners[i];\r\n            var isOnce = onceListeners && onceListeners[listener];\r\n            if (isOnce) {\r\n                // remove listener\r\n                // remove before trigger to prevent recursion\r\n                this.off(eventName, listener);\r\n                // unset once flag\r\n                delete onceListeners[listener];\r\n            }\r\n            // trigger listener\r\n            listener.apply(this, args);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    proto.allOff = function () {\r\n        delete this._events;\r\n        delete this._onceEvents;\r\n    };\r\n\r\n    return EvEmitter;\r\n});\r\n\r\n/*!\r\n * getSize v2.0.3\r\n * measure size of elements\r\n * MIT license\r\n */\r\n\r\n/* jshint browser: true, strict: true, undef: true, unused: true */\r\n/* globals console: false */\r\n\r\n(function (window, factory) {\r\n    /* jshint strict: false */ /* globals define, module */\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('get-size/get-size', factory);\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory();\r\n    } else {\r\n        // browser global\r\n        window.getSize = factory();\r\n    }\r\n})(window, function factory() {\r\n    'use strict';\r\n\r\n    // -------------------------- helpers -------------------------- //\r\n\r\n    // get a number from a string, not a percentage\r\n    function getStyleSize(value) {\r\n        var num = parseFloat(value);\r\n        // not a percent like '100%', and a number\r\n        var isValid = value.indexOf('%') == -1 && !isNaN(num);\r\n        return isValid && num;\r\n    }\r\n\r\n    function noop() {}\r\n\r\n    var logError =\r\n        typeof console == 'undefined'\r\n            ? noop\r\n            : function (message) {\r\n                  console.error(message);\r\n              };\r\n\r\n    // -------------------------- measurements -------------------------- //\r\n\r\n    var measurements = [\r\n        'paddingLeft',\r\n        'paddingRight',\r\n        'paddingTop',\r\n        'paddingBottom',\r\n        'marginLeft',\r\n        'marginRight',\r\n        'marginTop',\r\n        'marginBottom',\r\n        'borderLeftWidth',\r\n        'borderRightWidth',\r\n        'borderTopWidth',\r\n        'borderBottomWidth',\r\n    ];\r\n\r\n    var measurementsLength = measurements.length;\r\n\r\n    function getZeroSize() {\r\n        var size = {\r\n            width: 0,\r\n            height: 0,\r\n            innerWidth: 0,\r\n            innerHeight: 0,\r\n            outerWidth: 0,\r\n            outerHeight: 0,\r\n        };\r\n        for (var i = 0; i < measurementsLength; i++) {\r\n            var measurement = measurements[i];\r\n            size[measurement] = 0;\r\n        }\r\n        return size;\r\n    }\r\n\r\n    // -------------------------- getStyle -------------------------- //\r\n\r\n    /**\r\n     * getStyle, get style of element, check for Firefox bug\r\n     * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\r\n     */\r\n    function getStyle(elem) {\r\n        var style = getComputedStyle(elem);\r\n        if (!style) {\r\n            logError(\r\n                'Style returned ' +\r\n                    style +\r\n                    '. Are you running this code in a hidden iframe on Firefox? ' +\r\n                    'See https://bit.ly/getsizebug1'\r\n            );\r\n        }\r\n        return style;\r\n    }\r\n\r\n    // -------------------------- setup -------------------------- //\r\n\r\n    var isSetup = false;\r\n\r\n    var isBoxSizeOuter;\r\n\r\n    /**\r\n     * setup\r\n     * check isBoxSizerOuter\r\n     * do on first getSize() rather than on page load for Firefox bug\r\n     */\r\n    function setup() {\r\n        // setup once\r\n        if (isSetup) {\r\n            return;\r\n        }\r\n        isSetup = true;\r\n\r\n        // -------------------------- box sizing -------------------------- //\r\n\r\n        /**\r\n         * Chrome & Safari measure the outer-width on style.width on border-box elems\r\n         * IE11 & Firefox<29 measures the inner-width\r\n         */\r\n        var div = document.createElement('div');\r\n        div.style.width = '200px';\r\n        div.style.padding = '1px 2px 3px 4px';\r\n        div.style.borderStyle = 'solid';\r\n        div.style.borderWidth = '1px 2px 3px 4px';\r\n        div.style.boxSizing = 'border-box';\r\n\r\n        var body = document.body || document.documentElement;\r\n        body.appendChild(div);\r\n        var style = getStyle(div);\r\n        // round value for browser zoom. desandro/masonry#928\r\n        isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;\r\n        getSize.isBoxSizeOuter = isBoxSizeOuter;\r\n\r\n        body.removeChild(div);\r\n    }\r\n\r\n    // -------------------------- getSize -------------------------- //\r\n\r\n    function getSize(elem) {\r\n        setup();\r\n\r\n        // use querySeletor if elem is string\r\n        if (typeof elem == 'string') {\r\n            elem = document.querySelector(elem);\r\n        }\r\n\r\n        // do not proceed on non-objects\r\n        if (!elem || typeof elem != 'object' || !elem.nodeType) {\r\n            return;\r\n        }\r\n\r\n        var style = getStyle(elem);\r\n\r\n        // if hidden, everything is 0\r\n        if (style.display == 'none') {\r\n            return getZeroSize();\r\n        }\r\n\r\n        var size = {};\r\n        size.width = elem.offsetWidth;\r\n        size.height = elem.offsetHeight;\r\n\r\n        var isBorderBox = (size.isBorderBox = style.boxSizing == 'border-box');\r\n\r\n        // get all measurements\r\n        for (var i = 0; i < measurementsLength; i++) {\r\n            var measurement = measurements[i];\r\n            var value = style[measurement];\r\n            var num = parseFloat(value);\r\n            // any 'auto', 'medium' value will be 0\r\n            size[measurement] = !isNaN(num) ? num : 0;\r\n        }\r\n\r\n        var paddingWidth = size.paddingLeft + size.paddingRight;\r\n        var paddingHeight = size.paddingTop + size.paddingBottom;\r\n        var marginWidth = size.marginLeft + size.marginRight;\r\n        var marginHeight = size.marginTop + size.marginBottom;\r\n        var borderWidth = size.borderLeftWidth + size.borderRightWidth;\r\n        var borderHeight = size.borderTopWidth + size.borderBottomWidth;\r\n\r\n        var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\r\n\r\n        // overwrite width and height if we can get it from style\r\n        var styleWidth = getStyleSize(style.width);\r\n        if (styleWidth !== false) {\r\n            size.width =\r\n                styleWidth +\r\n                // add padding and border unless it's already including it\r\n                (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);\r\n        }\r\n\r\n        var styleHeight = getStyleSize(style.height);\r\n        if (styleHeight !== false) {\r\n            size.height =\r\n                styleHeight +\r\n                // add padding and border unless it's already including it\r\n                (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);\r\n        }\r\n\r\n        size.innerWidth = size.width - (paddingWidth + borderWidth);\r\n        size.innerHeight = size.height - (paddingHeight + borderHeight);\r\n\r\n        size.outerWidth = size.width + marginWidth;\r\n        size.outerHeight = size.height + marginHeight;\r\n\r\n        return size;\r\n    }\r\n\r\n    return getSize;\r\n});\r\n\r\n/**\r\n * matchesSelector v2.0.2\r\n * matchesSelector( element, '.selector' )\r\n * MIT license\r\n */\r\n\r\n/*jshint browser: true, strict: true, undef: true, unused: true */\r\n\r\n(function (window, factory) {\r\n    /*global define: false, module: false */\r\n    'use strict';\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('desandro-matches-selector/matches-selector', factory);\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory();\r\n    } else {\r\n        // browser global\r\n        window.matchesSelector = factory();\r\n    }\r\n})(window, function factory() {\r\n    'use strict';\r\n\r\n    var matchesMethod = (function () {\r\n        var ElemProto = window.Element.prototype;\r\n        // check for the standard method name first\r\n        if (ElemProto.matches) {\r\n            return 'matches';\r\n        }\r\n        // check un-prefixed\r\n        if (ElemProto.matchesSelector) {\r\n            return 'matchesSelector';\r\n        }\r\n        // check vendor prefixes\r\n        var prefixes = ['webkit', 'moz', 'ms', 'o'];\r\n\r\n        for (var i = 0; i < prefixes.length; i++) {\r\n            var prefix = prefixes[i];\r\n            var method = prefix + 'MatchesSelector';\r\n            if (ElemProto[method]) {\r\n                return method;\r\n            }\r\n        }\r\n    })();\r\n\r\n    return function matchesSelector(elem, selector) {\r\n        return elem[matchesMethod](selector);\r\n    };\r\n});\r\n\r\n/**\r\n * Fizzy UI utils v2.0.7\r\n * MIT license\r\n */\r\n\r\n/*jshint browser: true, undef: true, unused: true, strict: true */\r\n\r\n(function (window, factory) {\r\n    // universal module definition\r\n    /*jshint strict: false */ /*globals define, module, require */\r\n\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('fizzy-ui-utils/utils', [\r\n            'desandro-matches-selector/matches-selector',\r\n        ], function (matchesSelector) {\r\n            return factory(window, matchesSelector);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(window, require('desandro-matches-selector'));\r\n    } else {\r\n        // browser global\r\n        window.fizzyUIUtils = factory(window, window.matchesSelector);\r\n    }\r\n})(window, function factory(window, matchesSelector) {\r\n    var utils = {};\r\n\r\n    // ----- extend ----- //\r\n\r\n    // extends objects\r\n    utils.extend = function (a, b) {\r\n        for (var prop in b) {\r\n            a[prop] = b[prop];\r\n        }\r\n        return a;\r\n    };\r\n\r\n    // ----- modulo ----- //\r\n\r\n    utils.modulo = function (num, div) {\r\n        return ((num % div) + div) % div;\r\n    };\r\n\r\n    // ----- makeArray ----- //\r\n\r\n    var arraySlice = Array.prototype.slice;\r\n\r\n    // turn element or nodeList into an array\r\n    utils.makeArray = function (obj) {\r\n        if (Array.isArray(obj)) {\r\n            // use object if already an array\r\n            return obj;\r\n        }\r\n        // return empty array if undefined or null. #6\r\n        if (obj === null || obj === undefined) {\r\n            return [];\r\n        }\r\n\r\n        var isArrayLike =\r\n            typeof obj == 'object' && typeof obj.length == 'number';\r\n        if (isArrayLike) {\r\n            // convert nodeList to array\r\n            return arraySlice.call(obj);\r\n        }\r\n\r\n        // array of single index\r\n        return [obj];\r\n    };\r\n\r\n    // ----- removeFrom ----- //\r\n\r\n    utils.removeFrom = function (ary, obj) {\r\n        var index = ary.indexOf(obj);\r\n        if (index != -1) {\r\n            ary.splice(index, 1);\r\n        }\r\n    };\r\n\r\n    // ----- getParent ----- //\r\n\r\n    utils.getParent = function (elem, selector) {\r\n        while (elem.parentNode && elem != document.body) {\r\n            elem = elem.parentNode;\r\n            if (matchesSelector(elem, selector)) {\r\n                return elem;\r\n            }\r\n        }\r\n    };\r\n\r\n    // ----- getQueryElement ----- //\r\n\r\n    // use element as selector string\r\n    utils.getQueryElement = function (elem) {\r\n        if (typeof elem == 'string') {\r\n            return document.querySelector(elem);\r\n        }\r\n        return elem;\r\n    };\r\n\r\n    // ----- handleEvent ----- //\r\n\r\n    // enable .ontype to trigger from .addEventListener( elem, 'type' )\r\n    utils.handleEvent = function (event) {\r\n        var method = 'on' + event.type;\r\n        if (this[method]) {\r\n            this[method](event);\r\n        }\r\n    };\r\n\r\n    // ----- filterFindElements ----- //\r\n\r\n    utils.filterFindElements = function (elems, selector) {\r\n        // make array of elems\r\n        elems = utils.makeArray(elems);\r\n        var ffElems = [];\r\n\r\n        elems.forEach(function (elem) {\r\n            // check that elem is an actual element\r\n            if (!(elem instanceof HTMLElement)) {\r\n                return;\r\n            }\r\n            // add elem if no selector\r\n            if (!selector) {\r\n                ffElems.push(elem);\r\n                return;\r\n            }\r\n            // filter & find items if we have a selector\r\n            // filter\r\n            if (matchesSelector(elem, selector)) {\r\n                ffElems.push(elem);\r\n            }\r\n            // find children\r\n            var childElems = elem.querySelectorAll(selector);\r\n            // concat childElems to filterFound array\r\n            for (var i = 0; i < childElems.length; i++) {\r\n                ffElems.push(childElems[i]);\r\n            }\r\n        });\r\n\r\n        return ffElems;\r\n    };\r\n\r\n    // ----- debounceMethod ----- //\r\n\r\n    utils.debounceMethod = function (_class, methodName, threshold) {\r\n        threshold = threshold || 100;\r\n        // original method\r\n        var method = _class.prototype[methodName];\r\n        var timeoutName = methodName + 'Timeout';\r\n\r\n        _class.prototype[methodName] = function () {\r\n            var timeout = this[timeoutName];\r\n            clearTimeout(timeout);\r\n\r\n            var args = arguments;\r\n            var _this = this;\r\n            this[timeoutName] = setTimeout(function () {\r\n                method.apply(_this, args);\r\n                delete _this[timeoutName];\r\n            }, threshold);\r\n        };\r\n    };\r\n\r\n    // ----- docReady ----- //\r\n\r\n    utils.docReady = function (callback) {\r\n        var readyState = document.readyState;\r\n        if (readyState == 'complete' || readyState == 'interactive') {\r\n            // do async to allow for other scripts to run. metafizzy/flickity#441\r\n            setTimeout(callback);\r\n        } else {\r\n            document.addEventListener('DOMContentLoaded', callback);\r\n        }\r\n    };\r\n\r\n    // ----- htmlInit ----- //\r\n\r\n    // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\r\n    utils.toDashed = function (str) {\r\n        return str\r\n            .replace(/(.)([A-Z])/g, function (match, $1, $2) {\r\n                return $1 + '-' + $2;\r\n            })\r\n            .toLowerCase();\r\n    };\r\n\r\n    var console = window.console;\r\n    /**\r\n     * allow user to initialize classes via [data-namespace] or .js-namespace class\r\n     * htmlInit( Widget, 'widgetName' )\r\n     * options are parsed from data-namespace-options\r\n     */\r\n    utils.htmlInit = function (WidgetClass, namespace) {\r\n        utils.docReady(function () {\r\n            var dashedNamespace = utils.toDashed(namespace);\r\n            var dataAttr = 'data-' + dashedNamespace;\r\n            var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');\r\n            var jsDashElems = document.querySelectorAll(\r\n                '.js-' + dashedNamespace\r\n            );\r\n            var elems = utils\r\n                .makeArray(dataAttrElems)\r\n                .concat(utils.makeArray(jsDashElems));\r\n            var dataOptionsAttr = dataAttr + '-options';\r\n            var jQuery = window.jQuery;\r\n\r\n            elems.forEach(function (elem) {\r\n                var attr =\r\n                    elem.getAttribute(dataAttr) ||\r\n                    elem.getAttribute(dataOptionsAttr);\r\n                var options;\r\n                try {\r\n                    options = attr && JSON.parse(attr);\r\n                } catch (error) {\r\n                    // log error, do not initialize\r\n                    if (console) {\r\n                        console.error(\r\n                            'Error parsing ' +\r\n                                dataAttr +\r\n                                ' on ' +\r\n                                elem.className +\r\n                                ': ' +\r\n                                error\r\n                        );\r\n                    }\r\n                    return;\r\n                }\r\n                // initialize\r\n                var instance = new WidgetClass(elem, options);\r\n                // make available via $().data('namespace')\r\n                if (jQuery) {\r\n                    jQuery.data(elem, namespace, instance);\r\n                }\r\n            });\r\n        });\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    return utils;\r\n});\r\n\r\n// Flickity.Cell\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/cell', ['get-size/get-size'], function (getSize) {\r\n            return factory(window, getSize);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(window, require('get-size'));\r\n    } else {\r\n        // browser global\r\n        window.Flickity = window.Flickity || {};\r\n        window.Flickity.Cell = factory(window, window.getSize);\r\n    }\r\n})(window, function factory(window, getSize) {\r\n    function Cell(elem, parent) {\r\n        this.element = elem;\r\n        this.parent = parent;\r\n\r\n        this.create();\r\n    }\r\n\r\n    var proto = Cell.prototype;\r\n\r\n    proto.create = function () {\r\n        this.element.style.position = 'absolute';\r\n        this.element.setAttribute('aria-hidden', 'true');\r\n        this.x = 0;\r\n        this.shift = 0;\r\n        this.element.style[this.parent.originSide] = 0;\r\n    };\r\n\r\n    proto.destroy = function () {\r\n        // reset style\r\n        this.unselect();\r\n        this.element.style.position = '';\r\n        var side = this.parent.originSide;\r\n        this.element.style[side] = '';\r\n        this.element.style.transform = '';\r\n        this.element.removeAttribute('aria-hidden');\r\n    };\r\n\r\n    proto.getSize = function () {\r\n        this.size = getSize(this.element);\r\n    };\r\n\r\n    proto.setPosition = function (x) {\r\n        this.x = x;\r\n        this.updateTarget();\r\n        this.renderPosition(x);\r\n    };\r\n\r\n    // setDefaultTarget v1 method, backwards compatibility, remove in v3\r\n    proto.updateTarget = proto.setDefaultTarget = function () {\r\n        var marginProperty =\r\n            this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';\r\n        this.target =\r\n            this.x +\r\n            this.size[marginProperty] +\r\n            this.size.width * this.parent.cellAlign;\r\n    };\r\n\r\n    proto.renderPosition = function (x) {\r\n        // render position of cell with in slider\r\n        var sideOffset = this.parent.originSide === 'left' ? 1 : -1;\r\n\r\n        var adjustedX = this.parent.options.percentPosition\r\n            ? x * sideOffset * (this.parent.size.innerWidth / this.size.width)\r\n            : x * sideOffset;\r\n\r\n        this.element.style.transform =\r\n            'translateX(' + this.parent.getPositionValue(adjustedX) + ')';\r\n    };\r\n\r\n    proto.select = function () {\r\n        this.element.classList.add('is-selected');\r\n        this.element.removeAttribute('aria-hidden');\r\n    };\r\n\r\n    proto.unselect = function () {\r\n        this.element.classList.remove('is-selected');\r\n        this.element.setAttribute('aria-hidden', 'true');\r\n    };\r\n\r\n    /**\r\n     * @param {Integer} shift - 0, 1, or -1\r\n     */\r\n    proto.wrapShift = function (shift) {\r\n        this.shift = shift;\r\n        this.renderPosition(this.x + this.parent.slideableWidth * shift);\r\n    };\r\n\r\n    proto.remove = function () {\r\n        this.element.parentNode.removeChild(this.element);\r\n    };\r\n\r\n    return Cell;\r\n});\r\n\r\n// slide\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/slide', factory);\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory();\r\n    } else {\r\n        // browser global\r\n        window.Flickity = window.Flickity || {};\r\n        window.Flickity.Slide = factory();\r\n    }\r\n})(window, function factory() {\r\n    'use strict';\r\n\r\n    function Slide(parent) {\r\n        this.parent = parent;\r\n        this.isOriginLeft = parent.originSide == 'left';\r\n        this.cells = [];\r\n        this.outerWidth = 0;\r\n        this.height = 0;\r\n    }\r\n\r\n    var proto = Slide.prototype;\r\n\r\n    proto.addCell = function (cell) {\r\n        this.cells.push(cell);\r\n        this.outerWidth += cell.size.outerWidth;\r\n        this.height = Math.max(cell.size.outerHeight, this.height);\r\n        // first cell stuff\r\n        if (this.cells.length == 1) {\r\n            this.x = cell.x; // x comes from first cell\r\n            var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';\r\n            this.firstMargin = cell.size[beginMargin];\r\n        }\r\n    };\r\n\r\n    proto.updateTarget = function () {\r\n        var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';\r\n        var lastCell = this.getLastCell();\r\n        var lastMargin = lastCell ? lastCell.size[endMargin] : 0;\r\n        var slideWidth = this.outerWidth - (this.firstMargin + lastMargin);\r\n        this.target =\r\n            this.x + this.firstMargin + slideWidth * this.parent.cellAlign;\r\n    };\r\n\r\n    proto.getLastCell = function () {\r\n        return this.cells[this.cells.length - 1];\r\n    };\r\n\r\n    proto.select = function () {\r\n        this.cells.forEach(function (cell) {\r\n            cell.select();\r\n        });\r\n    };\r\n\r\n    proto.unselect = function () {\r\n        this.cells.forEach(function (cell) {\r\n            cell.unselect();\r\n        });\r\n    };\r\n\r\n    proto.getCellElements = function () {\r\n        return this.cells.map(function (cell) {\r\n            return cell.element;\r\n        });\r\n    };\r\n\r\n    return Slide;\r\n});\r\n\r\n// animate\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/animate', ['fizzy-ui-utils/utils'], function (\r\n            utils\r\n        ) {\r\n            return factory(window, utils);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(window, require('fizzy-ui-utils'));\r\n    } else {\r\n        // browser global\r\n        window.Flickity = window.Flickity || {};\r\n        window.Flickity.animatePrototype = factory(window, window.fizzyUIUtils);\r\n    }\r\n})(window, function factory(window, utils) {\r\n    // -------------------------- animate -------------------------- //\r\n\r\n    var proto = {};\r\n\r\n    proto.startAnimation = function () {\r\n        if (this.isAnimating) {\r\n            return;\r\n        }\r\n\r\n        this.isAnimating = true;\r\n        this.restingFrames = 0;\r\n        this.animate();\r\n    };\r\n\r\n    proto.animate = function () {\r\n        this.applyDragForce();\r\n        this.applySelectedAttraction();\r\n\r\n        var previousX = this.x;\r\n\r\n        this.integratePhysics();\r\n        this.positionSlider();\r\n        this.settle(previousX);\r\n        // animate next frame\r\n        if (this.isAnimating) {\r\n            var _this = this;\r\n            requestAnimationFrame(function animateFrame() {\r\n                _this.animate();\r\n            });\r\n        }\r\n    };\r\n\r\n    proto.positionSlider = function () {\r\n        var x = this.x;\r\n        // wrap position around\r\n        if (this.options.wrapAround && this.cells.length > 1) {\r\n            x = utils.modulo(x, this.slideableWidth);\r\n            x -= this.slideableWidth;\r\n            this.shiftWrapCells(x);\r\n        }\r\n\r\n        this.setTranslateX(x, this.isAnimating);\r\n        this.dispatchScrollEvent();\r\n    };\r\n\r\n    proto.setTranslateX = function (x, is3d) {\r\n        x += this.cursorPosition;\r\n        // reverse if right-to-left and using transform\r\n        x = this.options.rightToLeft ? -x : x;\r\n        var translateX = this.getPositionValue(x);\r\n        // use 3D transforms for hardware acceleration on iOS\r\n        // but use 2D when settled, for better font-rendering\r\n        this.slider.style.transform = is3d\r\n            ? 'translate3d(' + translateX + ',0,0)'\r\n            : 'translateX(' + translateX + ')';\r\n    };\r\n\r\n    proto.dispatchScrollEvent = function () {\r\n        var firstSlide = this.slides[0];\r\n        if (!firstSlide) {\r\n            return;\r\n        }\r\n        var positionX = -this.x - firstSlide.target;\r\n        var progress = positionX / this.slidesWidth;\r\n        this.dispatchEvent('scroll', null, [progress, positionX]);\r\n    };\r\n\r\n    proto.positionSliderAtSelected = function () {\r\n        if (!this.cells.length) {\r\n            return;\r\n        }\r\n        this.x = -this.selectedSlide.target;\r\n        this.velocity = 0; // stop wobble\r\n        this.positionSlider();\r\n    };\r\n\r\n    proto.getPositionValue = function (position) {\r\n        if (this.options.percentPosition) {\r\n            // percent position, round to 2 digits, like 12.34%\r\n            return (\r\n                Math.round((position / this.size.innerWidth) * 10000) * 0.01 +\r\n                '%'\r\n            );\r\n        } else {\r\n            // pixel positioning\r\n            return Math.round(position) + 'px';\r\n        }\r\n    };\r\n\r\n    proto.settle = function (previousX) {\r\n        // keep track of frames where x hasn't moved\r\n        var isResting =\r\n            !this.isPointerDown &&\r\n            Math.round(this.x * 100) == Math.round(previousX * 100);\r\n        if (isResting) {\r\n            this.restingFrames++;\r\n        }\r\n        // stop animating if resting for 3 or more frames\r\n        if (this.restingFrames > 2) {\r\n            this.isAnimating = false;\r\n            delete this.isFreeScrolling;\r\n            // render position with translateX when settled\r\n            this.positionSlider();\r\n            this.dispatchEvent('settle', null, [this.selectedIndex]);\r\n        }\r\n    };\r\n\r\n    proto.shiftWrapCells = function (x) {\r\n        // shift before cells\r\n        var beforeGap = this.cursorPosition + x;\r\n        this._shiftCells(this.beforeShiftCells, beforeGap, -1);\r\n        // shift after cells\r\n        var afterGap =\r\n            this.size.innerWidth -\r\n            (x + this.slideableWidth + this.cursorPosition);\r\n        this._shiftCells(this.afterShiftCells, afterGap, 1);\r\n    };\r\n\r\n    proto._shiftCells = function (cells, gap, shift) {\r\n        for (var i = 0; i < cells.length; i++) {\r\n            var cell = cells[i];\r\n            var cellShift = gap > 0 ? shift : 0;\r\n            cell.wrapShift(cellShift);\r\n            gap -= cell.size.outerWidth;\r\n        }\r\n    };\r\n\r\n    proto._unshiftCells = function (cells) {\r\n        if (!cells || !cells.length) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < cells.length; i++) {\r\n            cells[i].wrapShift(0);\r\n        }\r\n    };\r\n\r\n    // -------------------------- physics -------------------------- //\r\n\r\n    proto.integratePhysics = function () {\r\n        this.x += this.velocity;\r\n        this.velocity *= this.getFrictionFactor();\r\n    };\r\n\r\n    proto.applyForce = function (force) {\r\n        this.velocity += force;\r\n    };\r\n\r\n    proto.getFrictionFactor = function () {\r\n        return (\r\n            1 -\r\n            this.options[\r\n                this.isFreeScrolling ? 'freeScrollFriction' : 'friction'\r\n            ]\r\n        );\r\n    };\r\n\r\n    proto.getRestingPosition = function () {\r\n        // my thanks to Steven Wittens, who simplified this math greatly\r\n        return this.x + this.velocity / (1 - this.getFrictionFactor());\r\n    };\r\n\r\n    proto.applyDragForce = function () {\r\n        if (!this.isDraggable || !this.isPointerDown) {\r\n            return;\r\n        }\r\n        // change the position to drag position by applying force\r\n        var dragVelocity = this.dragX - this.x;\r\n        var dragForce = dragVelocity - this.velocity;\r\n        this.applyForce(dragForce);\r\n    };\r\n\r\n    proto.applySelectedAttraction = function () {\r\n        // do not attract if pointer down or no slides\r\n        var dragDown = this.isDraggable && this.isPointerDown;\r\n        if (dragDown || this.isFreeScrolling || !this.slides.length) {\r\n            return;\r\n        }\r\n        var distance = this.selectedSlide.target * -1 - this.x;\r\n        var force = distance * this.options.selectedAttraction;\r\n        this.applyForce(force);\r\n    };\r\n\r\n    return proto;\r\n});\r\n\r\n// Flickity main\r\n/* eslint-disable max-params */\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/flickity', [\r\n            'ev-emitter/ev-emitter',\r\n            'get-size/get-size',\r\n            'fizzy-ui-utils/utils',\r\n            './cell',\r\n            './slide',\r\n            './animate',\r\n        ], function (EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {\r\n            return factory(\r\n                window,\r\n                EvEmitter,\r\n                getSize,\r\n                utils,\r\n                Cell,\r\n                Slide,\r\n                animatePrototype\r\n            );\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            window,\r\n            require('ev-emitter'),\r\n            require('get-size'),\r\n            require('fizzy-ui-utils'),\r\n            require('./cell'),\r\n            require('./slide'),\r\n            require('./animate')\r\n        );\r\n    } else {\r\n        // browser global\r\n        var _Flickity = window.Flickity;\r\n\r\n        window.Flickity = factory(\r\n            window,\r\n            window.EvEmitter,\r\n            window.getSize,\r\n            window.fizzyUIUtils,\r\n            _Flickity.Cell,\r\n            _Flickity.Slide,\r\n            _Flickity.animatePrototype\r\n        );\r\n    }\r\n})(\r\n    window,\r\n    function factory(\r\n        window,\r\n        EvEmitter,\r\n        getSize,\r\n        utils,\r\n        Cell,\r\n        Slide,\r\n        animatePrototype\r\n    ) {\r\n        /* eslint-enable max-params */\r\n\r\n        // vars\r\n        var jQuery = window.jQuery;\r\n        var getComputedStyle = window.getComputedStyle;\r\n        var console = window.console;\r\n\r\n        function moveElements(elems, toElem) {\r\n            elems = utils.makeArray(elems);\r\n            while (elems.length) {\r\n                toElem.appendChild(elems.shift());\r\n            }\r\n        }\r\n\r\n        // -------------------------- Flickity -------------------------- //\r\n\r\n        // globally unique identifiers\r\n        var GUID = 0;\r\n        // internal store of all Flickity intances\r\n        var instances = {};\r\n\r\n        function Flickity(element, options) {\r\n            var queryElement = utils.getQueryElement(element);\r\n            if (!queryElement) {\r\n                if (console) {\r\n                    console.error(\r\n                        'Bad element for Flickity: ' + (queryElement || element)\r\n                    );\r\n                }\r\n                return;\r\n            }\r\n            this.element = queryElement;\r\n            // do not initialize twice on same element\r\n            if (this.element.flickityGUID) {\r\n                var instance = instances[this.element.flickityGUID];\r\n                if (instance) instance.option(options);\r\n                return instance;\r\n            }\r\n\r\n            // add jQuery\r\n            if (jQuery) {\r\n                this.$element = jQuery(this.element);\r\n            }\r\n            // options\r\n            this.options = utils.extend({}, this.constructor.defaults);\r\n            this.option(options);\r\n\r\n            // kick things off\r\n            this._create();\r\n        }\r\n\r\n        Flickity.defaults = {\r\n            accessibility: true,\r\n            // adaptiveHeight: false,\r\n            cellAlign: 'center',\r\n            // cellSelector: undefined,\r\n            // contain: false,\r\n            freeScrollFriction: 0.075, // friction when free-scrolling\r\n            friction: 0.28, // friction when selecting\r\n            namespaceJQueryEvents: true,\r\n            // initialIndex: 0,\r\n            percentPosition: true,\r\n            resize: true,\r\n            selectedAttraction: 0.025,\r\n            setGallerySize: true,\r\n            // watchCSS: false,\r\n            // wrapAround: false\r\n        };\r\n\r\n        // hash of methods triggered on _create()\r\n        Flickity.createMethods = [];\r\n\r\n        var proto = Flickity.prototype;\r\n        // inherit EventEmitter\r\n        utils.extend(proto, EvEmitter.prototype);\r\n\r\n        proto._create = function () {\r\n            // add id for Flickity.data\r\n            var id = (this.guid = ++GUID);\r\n            this.element.flickityGUID = id; // expando\r\n            instances[id] = this; // associate via id\r\n            // initial properties\r\n            this.selectedIndex = 0;\r\n            // how many frames slider has been in same position\r\n            this.restingFrames = 0;\r\n            // initial physics properties\r\n            this.x = 0;\r\n            this.velocity = 0;\r\n            this.originSide = this.options.rightToLeft ? 'right' : 'left';\r\n            // create viewport & slider\r\n            this.viewport = document.createElement('div');\r\n            this.viewport.className = 'flickity-viewport';\r\n            this._createSlider();\r\n\r\n            if (this.options.resize || this.options.watchCSS) {\r\n                window.addEventListener('resize', this);\r\n            }\r\n\r\n            // add listeners from on option\r\n            for (var eventName in this.options.on) {\r\n                var listener = this.options.on[eventName];\r\n                this.on(eventName, listener);\r\n            }\r\n\r\n            Flickity.createMethods.forEach(function (method) {\r\n                this[method]();\r\n            }, this);\r\n\r\n            if (this.options.watchCSS) {\r\n                this.watchCSS();\r\n            } else {\r\n                this.activate();\r\n            }\r\n        };\r\n\r\n        /**\r\n         * set options\r\n         * @param {Object} opts - options to extend\r\n         */\r\n        proto.option = function (opts) {\r\n            utils.extend(this.options, opts);\r\n        };\r\n\r\n        proto.activate = function () {\r\n            if (this.isActive) {\r\n                return;\r\n            }\r\n            this.isActive = true;\r\n            this.element.classList.add('flickity-enabled');\r\n            if (this.options.rightToLeft) {\r\n                this.element.classList.add('flickity-rtl');\r\n            }\r\n\r\n            this.getSize();\r\n            // move initial cell elements so they can be loaded as cells\r\n            var cellElems = this._filterFindCellElements(this.element.children);\r\n            moveElements(cellElems, this.slider);\r\n            this.viewport.appendChild(this.slider);\r\n            this.element.appendChild(this.viewport);\r\n            // get cells from children\r\n            this.reloadCells();\r\n\r\n            if (this.options.accessibility) {\r\n                // allow element to focusable\r\n                this.element.tabIndex = 0;\r\n                // listen for key presses\r\n                this.element.addEventListener('keydown', this);\r\n            }\r\n\r\n            this.emitEvent('activate');\r\n            this.selectInitialIndex();\r\n            // flag for initial activation, for using initialIndex\r\n            this.isInitActivated = true;\r\n            // ready event. #493\r\n            this.dispatchEvent('ready');\r\n        };\r\n\r\n        // slider positions the cells\r\n        proto._createSlider = function () {\r\n            // slider element does all the positioning\r\n            var slider = document.createElement('div');\r\n            slider.className = 'flickity-slider';\r\n            slider.style[this.originSide] = 0;\r\n            this.slider = slider;\r\n        };\r\n\r\n        proto._filterFindCellElements = function (elems) {\r\n            return utils.filterFindElements(elems, this.options.cellSelector);\r\n        };\r\n\r\n        // goes through all children\r\n        proto.reloadCells = function () {\r\n            // collection of item elements\r\n            this.cells = this._makeCells(this.slider.children);\r\n            this.positionCells();\r\n            this._getWrapShiftCells();\r\n            this.setGallerySize();\r\n        };\r\n\r\n        /**\r\n         * turn elements into Flickity.Cells\r\n         * @param {[Array, NodeList, HTMLElement]} elems - elements to make into cells\r\n         * @returns {Array} items - collection of new Flickity Cells\r\n         */\r\n        proto._makeCells = function (elems) {\r\n            var cellElems = this._filterFindCellElements(elems);\r\n\r\n            // create new Flickity for collection\r\n            var cells = cellElems.map(function (cellElem) {\r\n                return new Cell(cellElem, this);\r\n            }, this);\r\n\r\n            return cells;\r\n        };\r\n\r\n        proto.getLastCell = function () {\r\n            return this.cells[this.cells.length - 1];\r\n        };\r\n\r\n        proto.getLastSlide = function () {\r\n            return this.slides[this.slides.length - 1];\r\n        };\r\n\r\n        // positions all cells\r\n        proto.positionCells = function () {\r\n            // size all cells\r\n            this._sizeCells(this.cells);\r\n            // position all cells\r\n            this._positionCells(0);\r\n        };\r\n\r\n        /**\r\n         * position certain cells\r\n         * @param {Integer} index - which cell to start with\r\n         */\r\n        proto._positionCells = function (index) {\r\n            index = index || 0;\r\n            // also measure maxCellHeight\r\n            // start 0 if positioning all cells\r\n            this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;\r\n            var cellX = 0;\r\n            // get cellX\r\n            if (index > 0) {\r\n                var startCell = this.cells[index - 1];\r\n                cellX = startCell.x + startCell.size.outerWidth;\r\n            }\r\n            var len = this.cells.length;\r\n            for (var i = index; i < len; i++) {\r\n                var cell = this.cells[i];\r\n                cell.setPosition(cellX);\r\n                cellX += cell.size.outerWidth;\r\n                this.maxCellHeight = Math.max(\r\n                    cell.size.outerHeight,\r\n                    this.maxCellHeight\r\n                );\r\n            }\r\n            // keep track of cellX for wrap-around\r\n            this.slideableWidth = cellX;\r\n            // slides\r\n            this.updateSlides();\r\n            // contain slides target\r\n            this._containSlides();\r\n            // update slidesWidth\r\n            this.slidesWidth = len\r\n                ? this.getLastSlide().target - this.slides[0].target\r\n                : 0;\r\n        };\r\n\r\n        /**\r\n         * cell.getSize() on multiple cells\r\n         * @param {Array} cells - cells to size\r\n         */\r\n        proto._sizeCells = function (cells) {\r\n            cells.forEach(function (cell) {\r\n                cell.getSize();\r\n            });\r\n        };\r\n\r\n        // --------------------------  -------------------------- //\r\n\r\n        proto.updateSlides = function () {\r\n            this.slides = [];\r\n            if (!this.cells.length) {\r\n                return;\r\n            }\r\n\r\n            var slide = new Slide(this);\r\n            this.slides.push(slide);\r\n            var isOriginLeft = this.originSide == 'left';\r\n            var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';\r\n\r\n            var canCellFit = this._getCanCellFit();\r\n\r\n            this.cells.forEach(function (cell, i) {\r\n                // just add cell if first cell in slide\r\n                if (!slide.cells.length) {\r\n                    slide.addCell(cell);\r\n                    return;\r\n                }\r\n\r\n                var slideWidth =\r\n                    slide.outerWidth -\r\n                    slide.firstMargin +\r\n                    (cell.size.outerWidth - cell.size[nextMargin]);\r\n\r\n                if (canCellFit.call(this, i, slideWidth)) {\r\n                    slide.addCell(cell);\r\n                } else {\r\n                    // doesn't fit, new slide\r\n                    slide.updateTarget();\r\n\r\n                    slide = new Slide(this);\r\n                    this.slides.push(slide);\r\n                    slide.addCell(cell);\r\n                }\r\n            }, this);\r\n            // last slide\r\n            slide.updateTarget();\r\n            // update .selectedSlide\r\n            this.updateSelectedSlide();\r\n        };\r\n\r\n        proto._getCanCellFit = function () {\r\n            var groupCells = this.options.groupCells;\r\n            if (!groupCells) {\r\n                return function () {\r\n                    return false;\r\n                };\r\n            } else if (typeof groupCells == 'number') {\r\n                // group by number. 3 -> [0,1,2], [3,4,5], ...\r\n                var number = parseInt(groupCells, 10);\r\n                return function (i) {\r\n                    return i % number !== 0;\r\n                };\r\n            }\r\n            // default, group by width of slide\r\n            // parse '75%\r\n            var percentMatch =\r\n                typeof groupCells == 'string' && groupCells.match(/^(\\d+)%$/);\r\n            var percent = percentMatch\r\n                ? parseInt(percentMatch[1], 10) / 100\r\n                : 1;\r\n            return function (i, slideWidth) {\r\n                /* eslint-disable-next-line no-invalid-this */\r\n                return slideWidth <= (this.size.innerWidth + 1) * percent;\r\n            };\r\n        };\r\n\r\n        // alias _init for jQuery plugin .flickity()\r\n        proto._init = proto.reposition = function () {\r\n            this.positionCells();\r\n            this.positionSliderAtSelected();\r\n        };\r\n\r\n        proto.getSize = function () {\r\n            this.size = getSize(this.element);\r\n            this.setCellAlign();\r\n            this.cursorPosition = this.size.innerWidth * this.cellAlign;\r\n        };\r\n\r\n        var cellAlignShorthands = {\r\n            // cell align, then based on origin side\r\n            center: {\r\n                left: 0.5,\r\n                right: 0.5,\r\n            },\r\n            left: {\r\n                left: 0,\r\n                right: 1,\r\n            },\r\n            right: {\r\n                right: 0,\r\n                left: 1,\r\n            },\r\n        };\r\n\r\n        proto.setCellAlign = function () {\r\n            var shorthand = cellAlignShorthands[this.options.cellAlign];\r\n            this.cellAlign = shorthand\r\n                ? shorthand[this.originSide]\r\n                : this.options.cellAlign;\r\n        };\r\n\r\n        proto.setGallerySize = function () {\r\n            if (this.options.setGallerySize) {\r\n                var height =\r\n                    this.options.adaptiveHeight && this.selectedSlide\r\n                        ? this.selectedSlide.height\r\n                        : this.maxCellHeight;\r\n                this.viewport.style.height = height + 'px';\r\n            }\r\n        };\r\n\r\n        proto._getWrapShiftCells = function () {\r\n            // only for wrap-around\r\n            if (!this.options.wrapAround) {\r\n                return;\r\n            }\r\n            // unshift previous cells\r\n            this._unshiftCells(this.beforeShiftCells);\r\n            this._unshiftCells(this.afterShiftCells);\r\n            // get before cells\r\n            // initial gap\r\n            var gapX = this.cursorPosition;\r\n            var cellIndex = this.cells.length - 1;\r\n            this.beforeShiftCells = this._getGapCells(gapX, cellIndex, -1);\r\n            // get after cells\r\n            // ending gap between last cell and end of gallery viewport\r\n            gapX = this.size.innerWidth - this.cursorPosition;\r\n            // start cloning at first cell, working forwards\r\n            this.afterShiftCells = this._getGapCells(gapX, 0, 1);\r\n        };\r\n\r\n        proto._getGapCells = function (gapX, cellIndex, increment) {\r\n            // keep adding cells until the cover the initial gap\r\n            var cells = [];\r\n            while (gapX > 0) {\r\n                var cell = this.cells[cellIndex];\r\n                if (!cell) {\r\n                    break;\r\n                }\r\n                cells.push(cell);\r\n                cellIndex += increment;\r\n                gapX -= cell.size.outerWidth;\r\n            }\r\n            return cells;\r\n        };\r\n\r\n        // ----- contain ----- //\r\n\r\n        // contain cell targets so no excess sliding\r\n        proto._containSlides = function () {\r\n            if (\r\n                !this.options.contain ||\r\n                this.options.wrapAround ||\r\n                !this.cells.length\r\n            ) {\r\n                return;\r\n            }\r\n            var isRightToLeft = this.options.rightToLeft;\r\n            var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';\r\n            var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';\r\n            var contentWidth =\r\n                this.slideableWidth - this.getLastCell().size[endMargin];\r\n            // content is less than gallery size\r\n            var isContentSmaller = contentWidth < this.size.innerWidth;\r\n            // bounds\r\n            var beginBound =\r\n                this.cursorPosition + this.cells[0].size[beginMargin];\r\n            var endBound =\r\n                contentWidth - this.size.innerWidth * (1 - this.cellAlign);\r\n            // contain each cell target\r\n            this.slides.forEach(function (slide) {\r\n                if (isContentSmaller) {\r\n                    // all cells fit inside gallery\r\n                    slide.target = contentWidth * this.cellAlign;\r\n                } else {\r\n                    // contain to bounds\r\n                    slide.target = Math.max(slide.target, beginBound);\r\n                    slide.target = Math.min(slide.target, endBound);\r\n                }\r\n            }, this);\r\n        };\r\n\r\n        // -----  ----- //\r\n\r\n        /**\r\n         * emits events via eventEmitter and jQuery events\r\n         * @param {String} type - name of event\r\n         * @param {Event} event - original event\r\n         * @param {Array} args - extra arguments\r\n         */\r\n        proto.dispatchEvent = function (type, event, args) {\r\n            var emitArgs = event ? [event].concat(args) : args;\r\n            this.emitEvent(type, emitArgs);\r\n\r\n            if (jQuery && this.$element) {\r\n                // default trigger with type if no event\r\n                type += this.options.namespaceJQueryEvents ? '.flickity' : '';\r\n                var $event = type;\r\n                if (event) {\r\n                    // create jQuery event\r\n                    var jQEvent = new jQuery.Event(event);\r\n                    jQEvent.type = type;\r\n                    $event = jQEvent;\r\n                }\r\n                this.$element.trigger($event, args);\r\n            }\r\n        };\r\n\r\n        // -------------------------- select -------------------------- //\r\n\r\n        /**\r\n         * @param {Integer} index - index of the slide\r\n         * @param {Boolean} isWrap - will wrap-around to last/first if at the end\r\n         * @param {Boolean} isInstant - will immediately set position at selected cell\r\n         */\r\n        proto.select = function (index, isWrap, isInstant) {\r\n            if (!this.isActive) {\r\n                return;\r\n            }\r\n            index = parseInt(index, 10);\r\n            this._wrapSelect(index);\r\n\r\n            if (this.options.wrapAround || isWrap) {\r\n                index = utils.modulo(index, this.slides.length);\r\n            }\r\n            // bail if invalid index\r\n            if (!this.slides[index]) {\r\n                return;\r\n            }\r\n            var prevIndex = this.selectedIndex;\r\n            this.selectedIndex = index;\r\n            this.updateSelectedSlide();\r\n            if (isInstant) {\r\n                this.positionSliderAtSelected();\r\n            } else {\r\n                this.startAnimation();\r\n            }\r\n            if (this.options.adaptiveHeight) {\r\n                this.setGallerySize();\r\n            }\r\n            // events\r\n            this.dispatchEvent('select', null, [index]);\r\n            // change event if new index\r\n            if (index != prevIndex) {\r\n                this.dispatchEvent('change', null, [index]);\r\n            }\r\n            // old v1 event name, remove in v3\r\n            this.dispatchEvent('cellSelect');\r\n        };\r\n\r\n        // wraps position for wrapAround, to move to closest slide. #113\r\n        proto._wrapSelect = function (index) {\r\n            var len = this.slides.length;\r\n            var isWrapping = this.options.wrapAround && len > 1;\r\n            if (!isWrapping) {\r\n                return index;\r\n            }\r\n            var wrapIndex = utils.modulo(index, len);\r\n            // go to shortest\r\n            var delta = Math.abs(wrapIndex - this.selectedIndex);\r\n            var backWrapDelta = Math.abs(wrapIndex + len - this.selectedIndex);\r\n            var forewardWrapDelta = Math.abs(\r\n                wrapIndex - len - this.selectedIndex\r\n            );\r\n            if (!this.isDragSelect && backWrapDelta < delta) {\r\n                index += len;\r\n            } else if (!this.isDragSelect && forewardWrapDelta < delta) {\r\n                index -= len;\r\n            }\r\n            // wrap position so slider is within normal area\r\n            if (index < 0) {\r\n                this.x -= this.slideableWidth;\r\n            } else if (index >= len) {\r\n                this.x += this.slideableWidth;\r\n            }\r\n        };\r\n\r\n        proto.previous = function (isWrap, isInstant) {\r\n            this.select(this.selectedIndex - 1, isWrap, isInstant);\r\n        };\r\n\r\n        proto.next = function (isWrap, isInstant) {\r\n            this.select(this.selectedIndex + 1, isWrap, isInstant);\r\n        };\r\n\r\n        proto.updateSelectedSlide = function () {\r\n            var slide = this.slides[this.selectedIndex];\r\n            // selectedIndex could be outside of slides, if triggered before resize()\r\n            if (!slide) {\r\n                return;\r\n            }\r\n            // unselect previous selected slide\r\n            this.unselectSelectedSlide();\r\n            // update new selected slide\r\n            this.selectedSlide = slide;\r\n            slide.select();\r\n            this.selectedCells = slide.cells;\r\n            this.selectedElements = slide.getCellElements();\r\n            // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility\r\n            // Remove in v3?\r\n            this.selectedCell = slide.cells[0];\r\n            this.selectedElement = this.selectedElements[0];\r\n        };\r\n\r\n        proto.unselectSelectedSlide = function () {\r\n            if (this.selectedSlide) {\r\n                this.selectedSlide.unselect();\r\n            }\r\n        };\r\n\r\n        proto.selectInitialIndex = function () {\r\n            var initialIndex = this.options.initialIndex;\r\n            // already activated, select previous selectedIndex\r\n            if (this.isInitActivated) {\r\n                this.select(this.selectedIndex, false, true);\r\n                return;\r\n            }\r\n            // select with selector string\r\n            if (initialIndex && typeof initialIndex == 'string') {\r\n                var cell = this.queryCell(initialIndex);\r\n                if (cell) {\r\n                    this.selectCell(initialIndex, false, true);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            var index = 0;\r\n            // select with number\r\n            if (initialIndex && this.slides[initialIndex]) {\r\n                index = initialIndex;\r\n            }\r\n            // select instantly\r\n            this.select(index, false, true);\r\n        };\r\n\r\n        /**\r\n         * select slide from number or cell element\r\n         * @param {[Element, Number]} value - zero-based index or element to select\r\n         * @param {Boolean} isWrap - enables wrapping around for extra index\r\n         * @param {Boolean} isInstant - disables slide animation\r\n         */\r\n        proto.selectCell = function (value, isWrap, isInstant) {\r\n            // get cell\r\n            var cell = this.queryCell(value);\r\n            if (!cell) {\r\n                return;\r\n            }\r\n\r\n            var index = this.getCellSlideIndex(cell);\r\n            this.select(index, isWrap, isInstant);\r\n        };\r\n\r\n        proto.getCellSlideIndex = function (cell) {\r\n            // get index of slides that has cell\r\n            for (var i = 0; i < this.slides.length; i++) {\r\n                var slide = this.slides[i];\r\n                var index = slide.cells.indexOf(cell);\r\n                if (index != -1) {\r\n                    return i;\r\n                }\r\n            }\r\n        };\r\n\r\n        // -------------------------- get cells -------------------------- //\r\n\r\n        /**\r\n         * get Flickity.Cell, given an Element\r\n         * @param {Element} elem - matching cell element\r\n         * @returns {Flickity.Cell} cell - matching cell\r\n         */\r\n        proto.getCell = function (elem) {\r\n            // loop through cells to get the one that matches\r\n            for (var i = 0; i < this.cells.length; i++) {\r\n                var cell = this.cells[i];\r\n                if (cell.element == elem) {\r\n                    return cell;\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * get collection of Flickity.Cells, given Elements\r\n         * @param {[Element, Array, NodeList]} elems - multiple elements\r\n         * @returns {Array} cells - Flickity.Cells\r\n         */\r\n        proto.getCells = function (elems) {\r\n            elems = utils.makeArray(elems);\r\n            var cells = [];\r\n            elems.forEach(function (elem) {\r\n                var cell = this.getCell(elem);\r\n                if (cell) {\r\n                    cells.push(cell);\r\n                }\r\n            }, this);\r\n            return cells;\r\n        };\r\n\r\n        /**\r\n         * get cell elements\r\n         * @returns {Array} cellElems\r\n         */\r\n        proto.getCellElements = function () {\r\n            return this.cells.map(function (cell) {\r\n                return cell.element;\r\n            });\r\n        };\r\n\r\n        /**\r\n         * get parent cell from an element\r\n         * @param {Element} elem - child element\r\n         * @returns {Flickit.Cell} cell - parent cell\r\n         */\r\n        proto.getParentCell = function (elem) {\r\n            // first check if elem is cell\r\n            var cell = this.getCell(elem);\r\n            if (cell) {\r\n                return cell;\r\n            }\r\n            // try to get parent cell elem\r\n            elem = utils.getParent(elem, '.flickity-slider > *');\r\n            return this.getCell(elem);\r\n        };\r\n\r\n        /**\r\n         * get cells adjacent to a slide\r\n         * @param {Integer} adjCount - number of adjacent slides\r\n         * @param {Integer} index - index of slide to start\r\n         * @returns {Array} cells - array of Flickity.Cells\r\n         */\r\n        proto.getAdjacentCellElements = function (adjCount, index) {\r\n            if (!adjCount) {\r\n                return this.selectedSlide.getCellElements();\r\n            }\r\n            index = index === undefined ? this.selectedIndex : index;\r\n\r\n            var len = this.slides.length;\r\n            if (1 + adjCount * 2 >= len) {\r\n                return this.getCellElements();\r\n            }\r\n\r\n            var cellElems = [];\r\n            for (var i = index - adjCount; i <= index + adjCount; i++) {\r\n                var slideIndex = this.options.wrapAround\r\n                    ? utils.modulo(i, len)\r\n                    : i;\r\n                var slide = this.slides[slideIndex];\r\n                if (slide) {\r\n                    cellElems = cellElems.concat(slide.getCellElements());\r\n                }\r\n            }\r\n            return cellElems;\r\n        };\r\n\r\n        /**\r\n         * select slide from number or cell element\r\n         * @param {[Element, String, Number]} selector - element, selector string, or index\r\n         * @returns {Flickity.Cell} - matching cell\r\n         */\r\n        proto.queryCell = function (selector) {\r\n            if (typeof selector == 'number') {\r\n                // use number as index\r\n                return this.cells[selector];\r\n            }\r\n            if (typeof selector == 'string') {\r\n                // do not select invalid selectors from hash: #123, #/. #791\r\n                if (selector.match(/^[#.]?[\\d/]/)) {\r\n                    return;\r\n                }\r\n                // use string as selector, get element\r\n                selector = this.element.querySelector(selector);\r\n            }\r\n            // get cell from element\r\n            return this.getCell(selector);\r\n        };\r\n\r\n        // -------------------------- events -------------------------- //\r\n\r\n        proto.uiChange = function () {\r\n            this.emitEvent('uiChange');\r\n        };\r\n\r\n        // keep focus on element when child UI elements are clicked\r\n        proto.childUIPointerDown = function (event) {\r\n            // HACK iOS does not allow touch events to bubble up?!\r\n            if (event.type != 'touchstart') {\r\n                event.preventDefault();\r\n            }\r\n            this.focus();\r\n        };\r\n\r\n        // ----- resize ----- //\r\n\r\n        proto.onresize = function () {\r\n            this.watchCSS();\r\n            this.resize();\r\n        };\r\n\r\n        utils.debounceMethod(Flickity, 'onresize', 150);\r\n\r\n        proto.resize = function () {\r\n            // #1177 disable resize behavior when animating or dragging for iOS 15\r\n            if (!this.isActive || this.isAnimating || this.isDragging) {\r\n                return;\r\n            }\r\n            this.getSize();\r\n            // wrap values\r\n            if (this.options.wrapAround) {\r\n                this.x = utils.modulo(this.x, this.slideableWidth);\r\n            }\r\n            this.positionCells();\r\n            this._getWrapShiftCells();\r\n            this.setGallerySize();\r\n            this.emitEvent('resize');\r\n            // update selected index for group slides, instant\r\n            // TODO: position can be lost between groups of various numbers\r\n            var selectedElement =\r\n                this.selectedElements && this.selectedElements[0];\r\n            this.selectCell(selectedElement, false, true);\r\n        };\r\n\r\n        // watches the :after property, activates/deactivates\r\n        proto.watchCSS = function () {\r\n            var watchOption = this.options.watchCSS;\r\n            if (!watchOption) {\r\n                return;\r\n            }\r\n\r\n            var afterContent = getComputedStyle(this.element, ':after').content;\r\n            // activate if :after { content: 'flickity' }\r\n            if (afterContent.indexOf('flickity') != -1) {\r\n                this.activate();\r\n            } else {\r\n                this.deactivate();\r\n            }\r\n        };\r\n\r\n        // ----- keydown ----- //\r\n\r\n        // go previous/next if left/right keys pressed\r\n        proto.onkeydown = function (event) {\r\n            // only work if element is in focus\r\n            var isNotFocused =\r\n                document.activeElement &&\r\n                document.activeElement != this.element;\r\n            if (!this.options.accessibility || isNotFocused) {\r\n                return;\r\n            }\r\n\r\n            var handler = Flickity.keyboardHandlers[event.keyCode];\r\n            if (handler) {\r\n                handler.call(this);\r\n            }\r\n        };\r\n\r\n        Flickity.keyboardHandlers = {\r\n            // left arrow\r\n            37: function () {\r\n                var leftMethod = this.options.rightToLeft ? 'next' : 'previous';\r\n                this.uiChange();\r\n                this[leftMethod]();\r\n            },\r\n            // right arrow\r\n            39: function () {\r\n                var rightMethod = this.options.rightToLeft\r\n                    ? 'previous'\r\n                    : 'next';\r\n                this.uiChange();\r\n                this[rightMethod]();\r\n            },\r\n        };\r\n\r\n        // ----- focus ----- //\r\n\r\n        proto.focus = function () {\r\n            // TODO remove scrollTo once focus options gets more support\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus ...\r\n            //    #Browser_compatibility\r\n            var prevScrollY = window.pageYOffset;\r\n            this.element.focus({ preventScroll: true });\r\n            // hack to fix scroll jump after focus, #76\r\n            if (window.pageYOffset != prevScrollY) {\r\n                window.scrollTo(window.pageXOffset, prevScrollY);\r\n            }\r\n        };\r\n\r\n        // -------------------------- destroy -------------------------- //\r\n\r\n        // deactivate all Flickity functionality, but keep stuff available\r\n        proto.deactivate = function () {\r\n            if (!this.isActive) {\r\n                return;\r\n            }\r\n            this.element.classList.remove('flickity-enabled');\r\n            this.element.classList.remove('flickity-rtl');\r\n            this.unselectSelectedSlide();\r\n            // destroy cells\r\n            this.cells.forEach(function (cell) {\r\n                cell.destroy();\r\n            });\r\n            this.element.removeChild(this.viewport);\r\n            // move child elements back into element\r\n            moveElements(this.slider.children, this.element);\r\n            if (this.options.accessibility) {\r\n                this.element.removeAttribute('tabIndex');\r\n                this.element.removeEventListener('keydown', this);\r\n            }\r\n            // set flags\r\n            this.isActive = false;\r\n            this.emitEvent('deactivate');\r\n        };\r\n\r\n        proto.destroy = function () {\r\n            this.deactivate();\r\n            window.removeEventListener('resize', this);\r\n            this.allOff();\r\n            this.emitEvent('destroy');\r\n            if (jQuery && this.$element) {\r\n                jQuery.removeData(this.element, 'flickity');\r\n            }\r\n            delete this.element.flickityGUID;\r\n            delete instances[this.guid];\r\n        };\r\n\r\n        // -------------------------- prototype -------------------------- //\r\n\r\n        utils.extend(proto, animatePrototype);\r\n\r\n        // -------------------------- extras -------------------------- //\r\n\r\n        /**\r\n         * get Flickity instance from element\r\n         * @param {[Element, String]} elem - element or selector string\r\n         * @returns {Flickity} - Flickity instance\r\n         */\r\n        Flickity.data = function (elem) {\r\n            elem = utils.getQueryElement(elem);\r\n            var id = elem && elem.flickityGUID;\r\n            return id && instances[id];\r\n        };\r\n\r\n        utils.htmlInit(Flickity, 'flickity');\r\n\r\n        if (jQuery && jQuery.bridget) {\r\n            jQuery.bridget('flickity', Flickity);\r\n        }\r\n\r\n        // set internal jQuery, for Webpack + jQuery v3, #478\r\n        Flickity.setJQuery = function (jq) {\r\n            jQuery = jq;\r\n        };\r\n\r\n        Flickity.Cell = Cell;\r\n        Flickity.Slide = Slide;\r\n\r\n        return Flickity;\r\n    }\r\n);\r\n\r\n/*!\r\n * Unipointer v2.4.0\r\n * base class for doing one thing with pointer event\r\n * MIT license\r\n */\r\n\r\n/*jshint browser: true, undef: true, unused: true, strict: true */\r\n\r\n(function (window, factory) {\r\n    // universal module definition\r\n    /* jshint strict: false */ /*global define, module, require */\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('unipointer/unipointer', ['ev-emitter/ev-emitter'], function (\r\n            EvEmitter\r\n        ) {\r\n            return factory(window, EvEmitter);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(window, require('ev-emitter'));\r\n    } else {\r\n        // browser global\r\n        window.Unipointer = factory(window, window.EvEmitter);\r\n    }\r\n})(window, function factory(window, EvEmitter) {\r\n    function noop() {}\r\n\r\n    function Unipointer() {}\r\n\r\n    // inherit EvEmitter\r\n    var proto = (Unipointer.prototype = Object.create(EvEmitter.prototype));\r\n\r\n    proto.bindStartEvent = function (elem) {\r\n        this._bindStartEvent(elem, true);\r\n    };\r\n\r\n    proto.unbindStartEvent = function (elem) {\r\n        this._bindStartEvent(elem, false);\r\n    };\r\n\r\n    /**\r\n     * Add or remove start event\r\n     * @param {Boolean} isAdd - remove if falsey\r\n     */\r\n    proto._bindStartEvent = function (elem, isAdd) {\r\n        // munge isAdd, default to true\r\n        isAdd = isAdd === undefined ? true : isAdd;\r\n        var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\r\n\r\n        // default to mouse events\r\n        var startEvent = 'mousedown';\r\n        if ('ontouchstart' in window) {\r\n            // HACK prefer Touch Events as you can preventDefault on touchstart to\r\n            // disable scroll in iOS & mobile Chrome metafizzy/flickity#1177\r\n            startEvent = 'touchstart';\r\n        } else if (window.PointerEvent) {\r\n            // Pointer Events\r\n            startEvent = 'pointerdown';\r\n        }\r\n        elem[bindMethod](startEvent, this);\r\n    };\r\n\r\n    // trigger handler methods for events\r\n    proto.handleEvent = function (event) {\r\n        var method = 'on' + event.type;\r\n        if (this[method]) {\r\n            this[method](event);\r\n        }\r\n    };\r\n\r\n    // returns the touch that we're keeping track of\r\n    proto.getTouch = function (touches) {\r\n        for (var i = 0; i < touches.length; i++) {\r\n            var touch = touches[i];\r\n            if (touch.identifier == this.pointerIdentifier) {\r\n                return touch;\r\n            }\r\n        }\r\n    };\r\n\r\n    // ----- start event ----- //\r\n\r\n    proto.onmousedown = function (event) {\r\n        // dismiss clicks from right or middle buttons\r\n        var button = event.button;\r\n        if (button && button !== 0 && button !== 1) {\r\n            return;\r\n        }\r\n        this._pointerDown(event, event);\r\n    };\r\n\r\n    proto.ontouchstart = function (event) {\r\n        this._pointerDown(event, event.changedTouches[0]);\r\n    };\r\n\r\n    proto.onpointerdown = function (event) {\r\n        this._pointerDown(event, event);\r\n    };\r\n\r\n    /**\r\n     * pointer start\r\n     * @param {Event} event\r\n     * @param {Event or Touch} pointer\r\n     */\r\n    proto._pointerDown = function (event, pointer) {\r\n        // dismiss right click and other pointers\r\n        // button = 0 is okay, 1-4 not\r\n        if (event.button || this.isPointerDown) {\r\n            return;\r\n        }\r\n\r\n        this.isPointerDown = true;\r\n        // save pointer identifier to match up touch events\r\n        this.pointerIdentifier =\r\n            pointer.pointerId !== undefined\r\n                ? // pointerId for pointer events, touch.indentifier for touch events\r\n                  pointer.pointerId\r\n                : pointer.identifier;\r\n\r\n        this.pointerDown(event, pointer);\r\n    };\r\n\r\n    proto.pointerDown = function (event, pointer) {\r\n        this._bindPostStartEvents(event);\r\n        this.emitEvent('pointerDown', [event, pointer]);\r\n    };\r\n\r\n    // hash of events to be bound after start event\r\n    var postStartEvents = {\r\n        mousedown: ['mousemove', 'mouseup'],\r\n        touchstart: ['touchmove', 'touchend', 'touchcancel'],\r\n        pointerdown: ['pointermove', 'pointerup', 'pointercancel'],\r\n    };\r\n\r\n    proto._bindPostStartEvents = function (event) {\r\n        if (!event) {\r\n            return;\r\n        }\r\n        // get proper events to match start event\r\n        var events = postStartEvents[event.type];\r\n        // bind events to node\r\n        events.forEach(function (eventName) {\r\n            window.addEventListener(eventName, this);\r\n        }, this);\r\n        // save these arguments\r\n        this._boundPointerEvents = events;\r\n    };\r\n\r\n    proto._unbindPostStartEvents = function () {\r\n        // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\r\n        if (!this._boundPointerEvents) {\r\n            return;\r\n        }\r\n        this._boundPointerEvents.forEach(function (eventName) {\r\n            window.removeEventListener(eventName, this);\r\n        }, this);\r\n\r\n        delete this._boundPointerEvents;\r\n    };\r\n\r\n    // ----- move event ----- //\r\n\r\n    proto.onmousemove = function (event) {\r\n        this._pointerMove(event, event);\r\n    };\r\n\r\n    proto.onpointermove = function (event) {\r\n        if (event.pointerId == this.pointerIdentifier) {\r\n            this._pointerMove(event, event);\r\n        }\r\n    };\r\n\r\n    proto.ontouchmove = function (event) {\r\n        var touch = this.getTouch(event.changedTouches);\r\n        if (touch) {\r\n            this._pointerMove(event, touch);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * pointer move\r\n     * @param {Event} event\r\n     * @param {Event or Touch} pointer\r\n     * @private\r\n     */\r\n    proto._pointerMove = function (event, pointer) {\r\n        this.pointerMove(event, pointer);\r\n    };\r\n\r\n    // public\r\n    proto.pointerMove = function (event, pointer) {\r\n        this.emitEvent('pointerMove', [event, pointer]);\r\n    };\r\n\r\n    // ----- end event ----- //\r\n\r\n    proto.onmouseup = function (event) {\r\n        this._pointerUp(event, event);\r\n    };\r\n\r\n    proto.onpointerup = function (event) {\r\n        if (event.pointerId == this.pointerIdentifier) {\r\n            this._pointerUp(event, event);\r\n        }\r\n    };\r\n\r\n    proto.ontouchend = function (event) {\r\n        var touch = this.getTouch(event.changedTouches);\r\n        if (touch) {\r\n            this._pointerUp(event, touch);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * pointer up\r\n     * @param {Event} event\r\n     * @param {Event or Touch} pointer\r\n     * @private\r\n     */\r\n    proto._pointerUp = function (event, pointer) {\r\n        this._pointerDone();\r\n        this.pointerUp(event, pointer);\r\n    };\r\n\r\n    // public\r\n    proto.pointerUp = function (event, pointer) {\r\n        this.emitEvent('pointerUp', [event, pointer]);\r\n    };\r\n\r\n    // ----- pointer done ----- //\r\n\r\n    // triggered on pointer up & pointer cancel\r\n    proto._pointerDone = function () {\r\n        this._pointerReset();\r\n        this._unbindPostStartEvents();\r\n        this.pointerDone();\r\n    };\r\n\r\n    proto._pointerReset = function () {\r\n        // reset properties\r\n        this.isPointerDown = false;\r\n        delete this.pointerIdentifier;\r\n    };\r\n\r\n    proto.pointerDone = noop;\r\n\r\n    // ----- pointer cancel ----- //\r\n\r\n    proto.onpointercancel = function (event) {\r\n        if (event.pointerId == this.pointerIdentifier) {\r\n            this._pointerCancel(event, event);\r\n        }\r\n    };\r\n\r\n    proto.ontouchcancel = function (event) {\r\n        var touch = this.getTouch(event.changedTouches);\r\n        if (touch) {\r\n            this._pointerCancel(event, touch);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * pointer cancel\r\n     * @param {Event} event\r\n     * @param {Event or Touch} pointer\r\n     * @private\r\n     */\r\n    proto._pointerCancel = function (event, pointer) {\r\n        this._pointerDone();\r\n        this.pointerCancel(event, pointer);\r\n    };\r\n\r\n    // public\r\n    proto.pointerCancel = function (event, pointer) {\r\n        this.emitEvent('pointerCancel', [event, pointer]);\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    // utility function for getting x/y coords from event\r\n    Unipointer.getPointerPoint = function (pointer) {\r\n        return {\r\n            x: pointer.pageX,\r\n            y: pointer.pageY,\r\n        };\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    return Unipointer;\r\n});\r\n\r\n/*!\r\n * Unidragger v2.4.0\r\n * Draggable base class\r\n * MIT license\r\n */\r\n\r\n/*jshint browser: true, unused: true, undef: true, strict: true */\r\n\r\n(function (window, factory) {\r\n    // universal module definition\r\n    /*jshint strict: false */ /*globals define, module, require */\r\n\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('unidragger/unidragger', ['unipointer/unipointer'], function (\r\n            Unipointer\r\n        ) {\r\n            return factory(window, Unipointer);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(window, require('unipointer'));\r\n    } else {\r\n        // browser global\r\n        window.Unidragger = factory(window, window.Unipointer);\r\n    }\r\n})(window, function factory(window, Unipointer) {\r\n    // -------------------------- Unidragger -------------------------- //\r\n\r\n    function Unidragger() {}\r\n\r\n    // inherit Unipointer & EvEmitter\r\n    var proto = (Unidragger.prototype = Object.create(Unipointer.prototype));\r\n\r\n    // ----- bind start ----- //\r\n\r\n    proto.bindHandles = function () {\r\n        this._bindHandles(true);\r\n    };\r\n\r\n    proto.unbindHandles = function () {\r\n        this._bindHandles(false);\r\n    };\r\n\r\n    /**\r\n     * Add or remove start event\r\n     * @param {Boolean} isAdd\r\n     */\r\n    proto._bindHandles = function (isAdd) {\r\n        // munge isAdd, default to true\r\n        isAdd = isAdd === undefined ? true : isAdd;\r\n        // bind each handle\r\n        var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\r\n        var touchAction = isAdd ? this._touchActionValue : '';\r\n        for (var i = 0; i < this.handles.length; i++) {\r\n            var handle = this.handles[i];\r\n            this._bindStartEvent(handle, isAdd);\r\n            handle[bindMethod]('click', this);\r\n            // touch-action: none to override browser touch gestures. metafizzy/flickity#540\r\n            if (window.PointerEvent) {\r\n                handle.style.touchAction = touchAction;\r\n            }\r\n        }\r\n    };\r\n\r\n    // prototype so it can be overwriteable by Flickity\r\n    proto._touchActionValue = 'none';\r\n\r\n    // ----- start event ----- //\r\n\r\n    /**\r\n     * pointer start\r\n     * @param {Event} event\r\n     * @param {Event or Touch} pointer\r\n     */\r\n    proto.pointerDown = function (event, pointer) {\r\n        var isOkay = this.okayPointerDown(event);\r\n        if (!isOkay) {\r\n            return;\r\n        }\r\n        // track start event position\r\n        // Safari 9 overrides pageX and pageY. These values needs to be copied. flickity#842\r\n        this.pointerDownPointer = {\r\n            pageX: pointer.pageX,\r\n            pageY: pointer.pageY,\r\n        };\r\n\r\n        event.preventDefault();\r\n        this.pointerDownBlur();\r\n        // bind move and end events\r\n        this._bindPostStartEvents(event);\r\n        this.emitEvent('pointerDown', [event, pointer]);\r\n    };\r\n\r\n    // nodes that have text fields\r\n    var cursorNodes = {\r\n        TEXTAREA: true,\r\n        INPUT: true,\r\n        SELECT: true,\r\n        OPTION: true,\r\n    };\r\n\r\n    // input types that do not have text fields\r\n    var clickTypes = {\r\n        radio: true,\r\n        checkbox: true,\r\n        button: true,\r\n        submit: true,\r\n        image: true,\r\n        file: true,\r\n    };\r\n\r\n    // dismiss inputs with text fields. flickity#403, flickity#404\r\n    proto.okayPointerDown = function (event) {\r\n        var isCursorNode = cursorNodes[event.target.nodeName];\r\n        var isClickType = clickTypes[event.target.type];\r\n        var isOkay = !isCursorNode || isClickType;\r\n        if (!isOkay) {\r\n            this._pointerReset();\r\n        }\r\n        return isOkay;\r\n    };\r\n\r\n    // kludge to blur previously focused input\r\n    proto.pointerDownBlur = function () {\r\n        var focused = document.activeElement;\r\n        // do not blur body for IE10, metafizzy/flickity#117\r\n        var canBlur = focused && focused.blur && focused != document.body;\r\n        if (canBlur) {\r\n            focused.blur();\r\n        }\r\n    };\r\n\r\n    // ----- move event ----- //\r\n\r\n    /**\r\n     * drag move\r\n     * @param {Event} event\r\n     * @param {Event or Touch} pointer\r\n     */\r\n    proto.pointerMove = function (event, pointer) {\r\n        var moveVector = this._dragPointerMove(event, pointer);\r\n        this.emitEvent('pointerMove', [event, pointer, moveVector]);\r\n        this._dragMove(event, pointer, moveVector);\r\n    };\r\n\r\n    // base pointer move logic\r\n    proto._dragPointerMove = function (event, pointer) {\r\n        var moveVector = {\r\n            x: pointer.pageX - this.pointerDownPointer.pageX,\r\n            y: pointer.pageY - this.pointerDownPointer.pageY,\r\n        };\r\n        // start drag if pointer has moved far enough to start drag\r\n        if (!this.isDragging && this.hasDragStarted(moveVector)) {\r\n            this._dragStart(event, pointer);\r\n        }\r\n        return moveVector;\r\n    };\r\n\r\n    // condition if pointer has moved far enough to start drag\r\n    proto.hasDragStarted = function (moveVector) {\r\n        return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;\r\n    };\r\n\r\n    // ----- end event ----- //\r\n\r\n    /**\r\n     * pointer up\r\n     * @param {Event} event\r\n     * @param {Event or Touch} pointer\r\n     */\r\n    proto.pointerUp = function (event, pointer) {\r\n        this.emitEvent('pointerUp', [event, pointer]);\r\n        this._dragPointerUp(event, pointer);\r\n    };\r\n\r\n    proto._dragPointerUp = function (event, pointer) {\r\n        if (this.isDragging) {\r\n            this._dragEnd(event, pointer);\r\n        } else {\r\n            // pointer didn't move enough for drag to start\r\n            this._staticClick(event, pointer);\r\n        }\r\n    };\r\n\r\n    // -------------------------- drag -------------------------- //\r\n\r\n    // dragStart\r\n    proto._dragStart = function (event, pointer) {\r\n        this.isDragging = true;\r\n        // prevent clicks\r\n        this.isPreventingClicks = true;\r\n        this.dragStart(event, pointer);\r\n    };\r\n\r\n    proto.dragStart = function (event, pointer) {\r\n        this.emitEvent('dragStart', [event, pointer]);\r\n    };\r\n\r\n    // dragMove\r\n    proto._dragMove = function (event, pointer, moveVector) {\r\n        // do not drag if not dragging yet\r\n        if (!this.isDragging) {\r\n            return;\r\n        }\r\n\r\n        this.dragMove(event, pointer, moveVector);\r\n    };\r\n\r\n    proto.dragMove = function (event, pointer, moveVector) {\r\n        event.preventDefault();\r\n        this.emitEvent('dragMove', [event, pointer, moveVector]);\r\n    };\r\n\r\n    // dragEnd\r\n    proto._dragEnd = function (event, pointer) {\r\n        // set flags\r\n        this.isDragging = false;\r\n        // re-enable clicking async\r\n        setTimeout(\r\n            function () {\r\n                delete this.isPreventingClicks;\r\n            }.bind(this)\r\n        );\r\n\r\n        this.dragEnd(event, pointer);\r\n    };\r\n\r\n    proto.dragEnd = function (event, pointer) {\r\n        this.emitEvent('dragEnd', [event, pointer]);\r\n    };\r\n\r\n    // ----- onclick ----- //\r\n\r\n    // handle all clicks and prevent clicks when dragging\r\n    proto.onclick = function (event) {\r\n        if (this.isPreventingClicks) {\r\n            event.preventDefault();\r\n        }\r\n    };\r\n\r\n    // ----- staticClick ----- //\r\n\r\n    // triggered after pointer down & up with no/tiny movement\r\n    proto._staticClick = function (event, pointer) {\r\n        // ignore emulated mouse up clicks\r\n        if (this.isIgnoringMouseUp && event.type == 'mouseup') {\r\n            return;\r\n        }\r\n\r\n        this.staticClick(event, pointer);\r\n\r\n        // set flag for emulated clicks 300ms after touchend\r\n        if (event.type != 'mouseup') {\r\n            this.isIgnoringMouseUp = true;\r\n            // reset flag after 300ms\r\n            setTimeout(\r\n                function () {\r\n                    delete this.isIgnoringMouseUp;\r\n                }.bind(this),\r\n                400\r\n            );\r\n        }\r\n    };\r\n\r\n    proto.staticClick = function (event, pointer) {\r\n        this.emitEvent('staticClick', [event, pointer]);\r\n    };\r\n\r\n    // ----- utils ----- //\r\n\r\n    Unidragger.getPointerPoint = Unipointer.getPointerPoint;\r\n\r\n    // -----  ----- //\r\n\r\n    return Unidragger;\r\n});\r\n\r\n// drag\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/drag', [\r\n            './flickity',\r\n            'unidragger/unidragger',\r\n            'fizzy-ui-utils/utils',\r\n        ], function (Flickity, Unidragger, utils) {\r\n            return factory(window, Flickity, Unidragger, utils);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            window,\r\n            require('./flickity'),\r\n            require('unidragger'),\r\n            require('fizzy-ui-utils')\r\n        );\r\n    } else {\r\n        // browser global\r\n        window.Flickity = factory(\r\n            window,\r\n            window.Flickity,\r\n            window.Unidragger,\r\n            window.fizzyUIUtils\r\n        );\r\n    }\r\n})(window, function factory(window, Flickity, Unidragger, utils) {\r\n    // ----- defaults ----- //\r\n\r\n    utils.extend(Flickity.defaults, {\r\n        draggable: '>1',\r\n        dragThreshold: 3,\r\n    });\r\n\r\n    // ----- create ----- //\r\n\r\n    Flickity.createMethods.push('_createDrag');\r\n\r\n    // -------------------------- drag prototype -------------------------- //\r\n\r\n    var proto = Flickity.prototype;\r\n    utils.extend(proto, Unidragger.prototype);\r\n    proto._touchActionValue = 'pan-y';\r\n\r\n    // --------------------------  -------------------------- //\r\n\r\n    proto._createDrag = function () {\r\n        this.on('activate', this.onActivateDrag);\r\n        this.on('uiChange', this._uiChangeDrag);\r\n        this.on('deactivate', this.onDeactivateDrag);\r\n        this.on('cellChange', this.updateDraggable);\r\n        // TODO updateDraggable on resize? if groupCells & slides change\r\n    };\r\n\r\n    proto.onActivateDrag = function () {\r\n        this.handles = [this.viewport];\r\n        this.bindHandles();\r\n        this.updateDraggable();\r\n    };\r\n\r\n    proto.onDeactivateDrag = function () {\r\n        this.unbindHandles();\r\n        this.element.classList.remove('is-draggable');\r\n    };\r\n\r\n    proto.updateDraggable = function () {\r\n        // disable dragging if less than 2 slides. #278\r\n        if (this.options.draggable == '>1') {\r\n            this.isDraggable = this.slides.length > 1;\r\n        } else {\r\n            this.isDraggable = this.options.draggable;\r\n        }\r\n        if (this.isDraggable) {\r\n            this.element.classList.add('is-draggable');\r\n        } else {\r\n            this.element.classList.remove('is-draggable');\r\n        }\r\n    };\r\n\r\n    // backwards compatibility\r\n    proto.bindDrag = function () {\r\n        this.options.draggable = true;\r\n        this.updateDraggable();\r\n    };\r\n\r\n    proto.unbindDrag = function () {\r\n        this.options.draggable = false;\r\n        this.updateDraggable();\r\n    };\r\n\r\n    proto._uiChangeDrag = function () {\r\n        delete this.isFreeScrolling;\r\n    };\r\n\r\n    // -------------------------- pointer events -------------------------- //\r\n\r\n    proto.pointerDown = function (event, pointer) {\r\n        if (!this.isDraggable) {\r\n            this._pointerDownDefault(event, pointer);\r\n            return;\r\n        }\r\n        var isOkay = this.okayPointerDown(event);\r\n        if (!isOkay) {\r\n            return;\r\n        }\r\n\r\n        this._pointerDownPreventDefault(event);\r\n        this.pointerDownFocus(event);\r\n        // blur\r\n        if (document.activeElement != this.element) {\r\n            // do not blur if already focused\r\n            this.pointerDownBlur();\r\n        }\r\n\r\n        // stop if it was moving\r\n        this.dragX = this.x;\r\n        this.viewport.classList.add('is-pointer-down');\r\n        // track scrolling\r\n        this.pointerDownScroll = getScrollPosition();\r\n        window.addEventListener('scroll', this);\r\n\r\n        this._pointerDownDefault(event, pointer);\r\n    };\r\n\r\n    // default pointerDown logic, used for staticClick\r\n    proto._pointerDownDefault = function (event, pointer) {\r\n        // track start event position\r\n        // Safari 9 overrides pageX and pageY. These values needs to be copied. #779\r\n        this.pointerDownPointer = {\r\n            pageX: pointer.pageX,\r\n            pageY: pointer.pageY,\r\n        };\r\n        // bind move and end events\r\n        this._bindPostStartEvents(event);\r\n        this.dispatchEvent('pointerDown', event, [pointer]);\r\n    };\r\n\r\n    var focusNodes = {\r\n        INPUT: true,\r\n        TEXTAREA: true,\r\n        SELECT: true,\r\n    };\r\n\r\n    proto.pointerDownFocus = function (event) {\r\n        var isFocusNode = focusNodes[event.target.nodeName];\r\n        if (!isFocusNode) {\r\n            this.focus();\r\n        }\r\n    };\r\n\r\n    proto._pointerDownPreventDefault = function (event) {\r\n        var isTouchStart = event.type == 'touchstart';\r\n        var isTouchPointer = event.pointerType == 'touch';\r\n        var isFocusNode = focusNodes[event.target.nodeName];\r\n        if (!isTouchStart && !isTouchPointer && !isFocusNode) {\r\n            event.preventDefault();\r\n        }\r\n    };\r\n\r\n    // ----- move ----- //\r\n\r\n    proto.hasDragStarted = function (moveVector) {\r\n        return Math.abs(moveVector.x) > this.options.dragThreshold;\r\n    };\r\n\r\n    // ----- up ----- //\r\n\r\n    proto.pointerUp = function (event, pointer) {\r\n        delete this.isTouchScrolling;\r\n        this.viewport.classList.remove('is-pointer-down');\r\n        this.dispatchEvent('pointerUp', event, [pointer]);\r\n        this._dragPointerUp(event, pointer);\r\n    };\r\n\r\n    proto.pointerDone = function () {\r\n        window.removeEventListener('scroll', this);\r\n        delete this.pointerDownScroll;\r\n    };\r\n\r\n    // -------------------------- dragging -------------------------- //\r\n\r\n    proto.dragStart = function (event, pointer) {\r\n        if (!this.isDraggable) {\r\n            return;\r\n        }\r\n        this.dragStartPosition = this.x;\r\n        this.startAnimation();\r\n        window.removeEventListener('scroll', this);\r\n        this.dispatchEvent('dragStart', event, [pointer]);\r\n    };\r\n\r\n    proto.pointerMove = function (event, pointer) {\r\n        var moveVector = this._dragPointerMove(event, pointer);\r\n        this.dispatchEvent('pointerMove', event, [pointer, moveVector]);\r\n        this._dragMove(event, pointer, moveVector);\r\n    };\r\n\r\n    proto.dragMove = function (event, pointer, moveVector) {\r\n        if (!this.isDraggable) {\r\n            return;\r\n        }\r\n        event.preventDefault();\r\n\r\n        this.previousDragX = this.dragX;\r\n        // reverse if right-to-left\r\n        var direction = this.options.rightToLeft ? -1 : 1;\r\n        if (this.options.wrapAround) {\r\n            // wrap around move. #589\r\n            moveVector.x %= this.slideableWidth;\r\n        }\r\n        var dragX = this.dragStartPosition + moveVector.x * direction;\r\n\r\n        if (!this.options.wrapAround && this.slides.length) {\r\n            // slow drag\r\n            var originBound = Math.max(\r\n                -this.slides[0].target,\r\n                this.dragStartPosition\r\n            );\r\n            dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\r\n            var endBound = Math.min(\r\n                -this.getLastSlide().target,\r\n                this.dragStartPosition\r\n            );\r\n            dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\r\n        }\r\n\r\n        this.dragX = dragX;\r\n\r\n        this.dragMoveTime = new Date();\r\n        this.dispatchEvent('dragMove', event, [pointer, moveVector]);\r\n    };\r\n\r\n    proto.dragEnd = function (event, pointer) {\r\n        if (!this.isDraggable) {\r\n            return;\r\n        }\r\n        if (this.options.freeScroll) {\r\n            this.isFreeScrolling = true;\r\n        }\r\n        // set selectedIndex based on where flick will end up\r\n        var index = this.dragEndRestingSelect();\r\n\r\n        if (this.options.freeScroll && !this.options.wrapAround) {\r\n            // if free-scroll & not wrap around\r\n            // do not free-scroll if going outside of bounding slides\r\n            // so bounding slides can attract slider, and keep it in bounds\r\n            var restingX = this.getRestingPosition();\r\n            this.isFreeScrolling =\r\n                -restingX > this.slides[0].target &&\r\n                -restingX < this.getLastSlide().target;\r\n        } else if (!this.options.freeScroll && index == this.selectedIndex) {\r\n            // boost selection if selected index has not changed\r\n            index += this.dragEndBoostSelect();\r\n        }\r\n        delete this.previousDragX;\r\n        // apply selection\r\n        // TODO refactor this, selecting here feels weird\r\n        // HACK, set flag so dragging stays in correct direction\r\n        this.isDragSelect = this.options.wrapAround;\r\n        this.select(index);\r\n        delete this.isDragSelect;\r\n        this.dispatchEvent('dragEnd', event, [pointer]);\r\n    };\r\n\r\n    proto.dragEndRestingSelect = function () {\r\n        var restingX = this.getRestingPosition();\r\n        // how far away from selected slide\r\n        var distance = Math.abs(\r\n            this.getSlideDistance(-restingX, this.selectedIndex)\r\n        );\r\n        // get closet resting going up and going down\r\n        var positiveResting = this._getClosestResting(restingX, distance, 1);\r\n        var negativeResting = this._getClosestResting(restingX, distance, -1);\r\n        // use closer resting for wrap-around\r\n        var index =\r\n            positiveResting.distance < negativeResting.distance\r\n                ? positiveResting.index\r\n                : negativeResting.index;\r\n        return index;\r\n    };\r\n\r\n    /**\r\n     * given resting X and distance to selected cell\r\n     * get the distance and index of the closest cell\r\n     * @param {Number} restingX - estimated post-flick resting position\r\n     * @param {Number} distance - distance to selected cell\r\n     * @param {Integer} increment - +1 or -1, going up or down\r\n     * @returns {Object} - { distance: {Number}, index: {Integer} }\r\n     */\r\n    proto._getClosestResting = function (restingX, distance, increment) {\r\n        var index = this.selectedIndex;\r\n        var minDistance = Infinity;\r\n        var condition =\r\n            this.options.contain && !this.options.wrapAround\r\n                ? // if contain, keep going if distance is equal to minDistance\r\n                  function (dist, minDist) {\r\n                      return dist <= minDist;\r\n                  }\r\n                : function (dist, minDist) {\r\n                      return dist < minDist;\r\n                  };\r\n        while (condition(distance, minDistance)) {\r\n            // measure distance to next cell\r\n            index += increment;\r\n            minDistance = distance;\r\n            distance = this.getSlideDistance(-restingX, index);\r\n            if (distance === null) {\r\n                break;\r\n            }\r\n            distance = Math.abs(distance);\r\n        }\r\n        return {\r\n            distance: minDistance,\r\n            // selected was previous index\r\n            index: index - increment,\r\n        };\r\n    };\r\n\r\n    /**\r\n     * measure distance between x and a slide target\r\n     * @param {Number} x - horizontal position\r\n     * @param {Integer} index - slide index\r\n     * @returns {Number} - slide distance\r\n     */\r\n    proto.getSlideDistance = function (x, index) {\r\n        var len = this.slides.length;\r\n        // wrap around if at least 2 slides\r\n        var isWrapAround = this.options.wrapAround && len > 1;\r\n        var slideIndex = isWrapAround ? utils.modulo(index, len) : index;\r\n        var slide = this.slides[slideIndex];\r\n        if (!slide) {\r\n            return null;\r\n        }\r\n        // add distance for wrap-around slides\r\n        var wrap = isWrapAround\r\n            ? this.slideableWidth * Math.floor(index / len)\r\n            : 0;\r\n        return x - (slide.target + wrap);\r\n    };\r\n\r\n    proto.dragEndBoostSelect = function () {\r\n        // do not boost if no previousDragX or dragMoveTime\r\n        if (\r\n            this.previousDragX === undefined ||\r\n            !this.dragMoveTime ||\r\n            // or if drag was held for 100 ms\r\n            new Date() - this.dragMoveTime > 100\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\r\n        var delta = this.previousDragX - this.dragX;\r\n        if (distance > 0 && delta > 0) {\r\n            // boost to next if moving towards the right, and positive velocity\r\n            return 1;\r\n        } else if (distance < 0 && delta < 0) {\r\n            // boost to previous if moving towards the left, and negative velocity\r\n            return -1;\r\n        }\r\n        return 0;\r\n    };\r\n\r\n    // ----- staticClick ----- //\r\n\r\n    proto.staticClick = function (event, pointer) {\r\n        // get clickedCell, if cell was clicked\r\n        var clickedCell = this.getParentCell(event.target);\r\n        var cellElem = clickedCell && clickedCell.element;\r\n        var cellIndex = clickedCell && this.cells.indexOf(clickedCell);\r\n        this.dispatchEvent('staticClick', event, [\r\n            pointer,\r\n            cellElem,\r\n            cellIndex,\r\n        ]);\r\n    };\r\n\r\n    // ----- scroll ----- //\r\n\r\n    proto.onscroll = function () {\r\n        var scroll = getScrollPosition();\r\n        var scrollMoveX = this.pointerDownScroll.x - scroll.x;\r\n        var scrollMoveY = this.pointerDownScroll.y - scroll.y;\r\n        // cancel click/tap if scroll is too much\r\n        if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\r\n            this._pointerDone();\r\n        }\r\n    };\r\n\r\n    // ----- utils ----- //\r\n\r\n    function getScrollPosition() {\r\n        return {\r\n            x: window.pageXOffset,\r\n            y: window.pageYOffset,\r\n        };\r\n    }\r\n\r\n    // -----  ----- //\r\n\r\n    return Flickity;\r\n});\r\n\r\n// prev/next buttons\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/prev-next-button', [\r\n            './flickity',\r\n            'unipointer/unipointer',\r\n            'fizzy-ui-utils/utils',\r\n        ], function (Flickity, Unipointer, utils) {\r\n            return factory(window, Flickity, Unipointer, utils);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            window,\r\n            require('./flickity'),\r\n            require('unipointer'),\r\n            require('fizzy-ui-utils')\r\n        );\r\n    } else {\r\n        // browser global\r\n        factory(\r\n            window,\r\n            window.Flickity,\r\n            window.Unipointer,\r\n            window.fizzyUIUtils\r\n        );\r\n    }\r\n})(window, function factory(window, Flickity, Unipointer, utils) {\r\n    'use strict';\r\n\r\n    var svgURI = 'http://www.w3.org/2000/svg';\r\n\r\n    // -------------------------- PrevNextButton -------------------------- //\r\n\r\n    function PrevNextButton(direction, parent) {\r\n        this.direction = direction;\r\n        this.parent = parent;\r\n        this._create();\r\n    }\r\n\r\n    PrevNextButton.prototype = Object.create(Unipointer.prototype);\r\n\r\n    PrevNextButton.prototype._create = function () {\r\n        // properties\r\n        this.isEnabled = true;\r\n        this.isPrevious = this.direction == -1;\r\n        var leftDirection = this.parent.options.rightToLeft ? 1 : -1;\r\n        this.isLeft = this.direction == leftDirection;\r\n\r\n        var element = (this.element = document.createElement('button'));\r\n        element.className = 'flickity-button flickity-prev-next-button';\r\n        element.className += this.isPrevious ? ' previous' : ' next';\r\n        // prevent button from submitting form http://stackoverflow.com/a/10836076/182183\r\n        element.setAttribute('type', 'button');\r\n        // init as disabled\r\n        this.disable();\r\n\r\n        element.setAttribute(\r\n            'aria-label',\r\n            this.isPrevious ? 'Previous' : 'Next'\r\n        );\r\n\r\n        // create arrow\r\n        var svg = this.createSVG();\r\n        element.appendChild(svg);\r\n        // events\r\n        this.parent.on('select', this.update.bind(this));\r\n        this.on(\r\n            'pointerDown',\r\n            this.parent.childUIPointerDown.bind(this.parent)\r\n        );\r\n    };\r\n\r\n    PrevNextButton.prototype.activate = function () {\r\n        this.bindStartEvent(this.element);\r\n        this.element.addEventListener('click', this);\r\n        // add to DOM\r\n        this.parent.element.appendChild(this.element);\r\n    };\r\n\r\n    PrevNextButton.prototype.deactivate = function () {\r\n        // remove from DOM\r\n        this.parent.element.removeChild(this.element);\r\n        // click events\r\n        this.unbindStartEvent(this.element);\r\n        this.element.removeEventListener('click', this);\r\n    };\r\n\r\n    PrevNextButton.prototype.createSVG = function () {\r\n        var svg = document.createElementNS(svgURI, 'svg');\r\n        svg.setAttribute('class', 'flickity-button-icon');\r\n        svg.setAttribute('viewBox', '0 0 100 100');\r\n        var path = document.createElementNS(svgURI, 'path');\r\n        var pathMovements = getArrowMovements(this.parent.options.arrowShape);\r\n        path.setAttribute('d', pathMovements);\r\n        path.setAttribute('class', 'arrow');\r\n        // rotate arrow\r\n        if (!this.isLeft) {\r\n            path.setAttribute('transform', 'translate(100, 100) rotate(180) ');\r\n        }\r\n        svg.appendChild(path);\r\n        return svg;\r\n    };\r\n\r\n    // get SVG path movmement\r\n    function getArrowMovements(shape) {\r\n        // use shape as movement if string\r\n        if (typeof shape == 'string') {\r\n            return shape;\r\n        }\r\n        // create movement string\r\n        return (\r\n            'M ' +\r\n            shape.x0 +\r\n            ',50' +\r\n            ' L ' +\r\n            shape.x1 +\r\n            ',' +\r\n            (shape.y1 + 50) +\r\n            ' L ' +\r\n            shape.x2 +\r\n            ',' +\r\n            (shape.y2 + 50) +\r\n            ' L ' +\r\n            shape.x3 +\r\n            ',50 ' +\r\n            ' L ' +\r\n            shape.x2 +\r\n            ',' +\r\n            (50 - shape.y2) +\r\n            ' L ' +\r\n            shape.x1 +\r\n            ',' +\r\n            (50 - shape.y1) +\r\n            ' Z'\r\n        );\r\n    }\r\n\r\n    PrevNextButton.prototype.handleEvent = utils.handleEvent;\r\n\r\n    PrevNextButton.prototype.onclick = function () {\r\n        if (!this.isEnabled) {\r\n            return;\r\n        }\r\n        this.parent.uiChange();\r\n        var method = this.isPrevious ? 'previous' : 'next';\r\n        this.parent[method]();\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    PrevNextButton.prototype.enable = function () {\r\n        if (this.isEnabled) {\r\n            return;\r\n        }\r\n        this.element.disabled = false;\r\n        this.isEnabled = true;\r\n    };\r\n\r\n    PrevNextButton.prototype.disable = function () {\r\n        if (!this.isEnabled) {\r\n            return;\r\n        }\r\n        this.element.disabled = true;\r\n        this.isEnabled = false;\r\n    };\r\n\r\n    PrevNextButton.prototype.update = function () {\r\n        // index of first or last slide, if previous or next\r\n        var slides = this.parent.slides;\r\n        // enable is wrapAround and at least 2 slides\r\n        if (this.parent.options.wrapAround && slides.length > 1) {\r\n            this.enable();\r\n            return;\r\n        }\r\n        var lastIndex = slides.length ? slides.length - 1 : 0;\r\n        var boundIndex = this.isPrevious ? 0 : lastIndex;\r\n        var method =\r\n            this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';\r\n        this[method]();\r\n    };\r\n\r\n    PrevNextButton.prototype.destroy = function () {\r\n        this.deactivate();\r\n        this.allOff();\r\n    };\r\n\r\n    // -------------------------- Flickity prototype -------------------------- //\r\n\r\n    utils.extend(Flickity.defaults, {\r\n        prevNextButtons: true,\r\n        arrowShape: {\r\n            x0: 10,\r\n            x1: 60,\r\n            y1: 50,\r\n            x2: 70,\r\n            y2: 40,\r\n            x3: 30,\r\n        },\r\n    });\r\n\r\n    Flickity.createMethods.push('_createPrevNextButtons');\r\n    var proto = Flickity.prototype;\r\n\r\n    proto._createPrevNextButtons = function () {\r\n        if (!this.options.prevNextButtons) {\r\n            return;\r\n        }\r\n\r\n        this.prevButton = new PrevNextButton(-1, this);\r\n        this.nextButton = new PrevNextButton(1, this);\r\n\r\n        this.on('activate', this.activatePrevNextButtons);\r\n    };\r\n\r\n    proto.activatePrevNextButtons = function () {\r\n        this.prevButton.activate();\r\n        this.nextButton.activate();\r\n        this.on('deactivate', this.deactivatePrevNextButtons);\r\n    };\r\n\r\n    proto.deactivatePrevNextButtons = function () {\r\n        this.prevButton.deactivate();\r\n        this.nextButton.deactivate();\r\n        this.off('deactivate', this.deactivatePrevNextButtons);\r\n    };\r\n\r\n    // --------------------------  -------------------------- //\r\n\r\n    Flickity.PrevNextButton = PrevNextButton;\r\n\r\n    return Flickity;\r\n});\r\n\r\n// page dots\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/page-dots', [\r\n            './flickity',\r\n            'unipointer/unipointer',\r\n            'fizzy-ui-utils/utils',\r\n        ], function (Flickity, Unipointer, utils) {\r\n            return factory(window, Flickity, Unipointer, utils);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            window,\r\n            require('./flickity'),\r\n            require('unipointer'),\r\n            require('fizzy-ui-utils')\r\n        );\r\n    } else {\r\n        // browser global\r\n        factory(\r\n            window,\r\n            window.Flickity,\r\n            window.Unipointer,\r\n            window.fizzyUIUtils\r\n        );\r\n    }\r\n})(window, function factory(window, Flickity, Unipointer, utils) {\r\n    // -------------------------- PageDots -------------------------- //\r\n\r\n    function PageDots(parent) {\r\n        this.parent = parent;\r\n        this._create();\r\n    }\r\n\r\n    PageDots.prototype = Object.create(Unipointer.prototype);\r\n\r\n    PageDots.prototype._create = function () {\r\n        // create holder element\r\n        this.holder = document.createElement('ol');\r\n        this.holder.className = 'flickity-page-dots';\r\n        // create dots, array of elements\r\n        this.dots = [];\r\n        // events\r\n        this.handleClick = this.onClick.bind(this);\r\n        this.on(\r\n            'pointerDown',\r\n            this.parent.childUIPointerDown.bind(this.parent)\r\n        );\r\n    };\r\n\r\n    PageDots.prototype.activate = function () {\r\n        this.setDots();\r\n        this.holder.addEventListener('click', this.handleClick);\r\n        this.bindStartEvent(this.holder);\r\n        // add to DOM\r\n        this.parent.element.appendChild(this.holder);\r\n    };\r\n\r\n    PageDots.prototype.deactivate = function () {\r\n        this.holder.removeEventListener('click', this.handleClick);\r\n        this.unbindStartEvent(this.holder);\r\n        // remove from DOM\r\n        this.parent.element.removeChild(this.holder);\r\n    };\r\n\r\n    PageDots.prototype.setDots = function () {\r\n        // get difference between number of slides and number of dots\r\n        var delta = this.parent.slides.length - this.dots.length;\r\n        if (delta > 0) {\r\n            this.addDots(delta);\r\n        } else if (delta < 0) {\r\n            this.removeDots(-delta);\r\n        }\r\n    };\r\n\r\n    PageDots.prototype.addDots = function (count) {\r\n        var fragment = document.createDocumentFragment();\r\n        var newDots = [];\r\n        var length = this.dots.length;\r\n        var max = length + count;\r\n\r\n        for (var i = length; i < max; i++) {\r\n            var dot = document.createElement('li');\r\n            dot.className = 'dot';\r\n            dot.setAttribute('aria-label', 'Page dot ' + (i + 1));\r\n            fragment.appendChild(dot);\r\n            newDots.push(dot);\r\n        }\r\n\r\n        this.holder.appendChild(fragment);\r\n        this.dots = this.dots.concat(newDots);\r\n    };\r\n\r\n    PageDots.prototype.removeDots = function (count) {\r\n        // remove from this.dots collection\r\n        var removeDots = this.dots.splice(this.dots.length - count, count);\r\n        // remove from DOM\r\n        removeDots.forEach(function (dot) {\r\n            this.holder.removeChild(dot);\r\n        }, this);\r\n    };\r\n\r\n    PageDots.prototype.updateSelected = function () {\r\n        // remove selected class on previous\r\n        if (this.selectedDot) {\r\n            this.selectedDot.className = 'dot';\r\n            this.selectedDot.removeAttribute('aria-current');\r\n        }\r\n        // don't proceed if no dots\r\n        if (!this.dots.length) {\r\n            return;\r\n        }\r\n        this.selectedDot = this.dots[this.parent.selectedIndex];\r\n        this.selectedDot.className = 'dot is-selected';\r\n        this.selectedDot.setAttribute('aria-current', 'step');\r\n    };\r\n\r\n    PageDots.prototype.onTap = // old method name, backwards-compatible\r\n        PageDots.prototype.onClick = function (event) {\r\n            var target = event.target;\r\n            // only care about dot clicks\r\n            if (target.nodeName != 'LI') {\r\n                return;\r\n            }\r\n\r\n            this.parent.uiChange();\r\n            var index = this.dots.indexOf(target);\r\n            this.parent.select(index);\r\n        };\r\n\r\n    PageDots.prototype.destroy = function () {\r\n        this.deactivate();\r\n        this.allOff();\r\n    };\r\n\r\n    Flickity.PageDots = PageDots;\r\n\r\n    // -------------------------- Flickity -------------------------- //\r\n\r\n    utils.extend(Flickity.defaults, {\r\n        pageDots: true,\r\n    });\r\n\r\n    Flickity.createMethods.push('_createPageDots');\r\n\r\n    var proto = Flickity.prototype;\r\n\r\n    proto._createPageDots = function () {\r\n        if (!this.options.pageDots) {\r\n            return;\r\n        }\r\n        this.pageDots = new PageDots(this);\r\n        // events\r\n        this.on('activate', this.activatePageDots);\r\n        this.on('select', this.updateSelectedPageDots);\r\n        this.on('cellChange', this.updatePageDots);\r\n        this.on('resize', this.updatePageDots);\r\n        this.on('deactivate', this.deactivatePageDots);\r\n    };\r\n\r\n    proto.activatePageDots = function () {\r\n        this.pageDots.activate();\r\n    };\r\n\r\n    proto.updateSelectedPageDots = function () {\r\n        this.pageDots.updateSelected();\r\n    };\r\n\r\n    proto.updatePageDots = function () {\r\n        this.pageDots.setDots();\r\n    };\r\n\r\n    proto.deactivatePageDots = function () {\r\n        this.pageDots.deactivate();\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    Flickity.PageDots = PageDots;\r\n\r\n    return Flickity;\r\n});\r\n\r\n// player & autoPlay\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/player', [\r\n            'ev-emitter/ev-emitter',\r\n            'fizzy-ui-utils/utils',\r\n            './flickity',\r\n        ], function (EvEmitter, utils, Flickity) {\r\n            return factory(EvEmitter, utils, Flickity);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            require('ev-emitter'),\r\n            require('fizzy-ui-utils'),\r\n            require('./flickity')\r\n        );\r\n    } else {\r\n        // browser global\r\n        factory(window.EvEmitter, window.fizzyUIUtils, window.Flickity);\r\n    }\r\n})(window, function factory(EvEmitter, utils, Flickity) {\r\n    // -------------------------- Player -------------------------- //\r\n\r\n    function Player(parent) {\r\n        this.parent = parent;\r\n        this.state = 'stopped';\r\n        // visibility change event handler\r\n        this.onVisibilityChange = this.visibilityChange.bind(this);\r\n        this.onVisibilityPlay = this.visibilityPlay.bind(this);\r\n    }\r\n\r\n    Player.prototype = Object.create(EvEmitter.prototype);\r\n\r\n    // start play\r\n    Player.prototype.play = function () {\r\n        if (this.state == 'playing') {\r\n            return;\r\n        }\r\n        // do not play if page is hidden, start playing when page is visible\r\n        var isPageHidden = document.hidden;\r\n        if (isPageHidden) {\r\n            document.addEventListener(\r\n                'visibilitychange',\r\n                this.onVisibilityPlay\r\n            );\r\n            return;\r\n        }\r\n\r\n        this.state = 'playing';\r\n        // listen to visibility change\r\n        document.addEventListener('visibilitychange', this.onVisibilityChange);\r\n        // start ticking\r\n        this.tick();\r\n    };\r\n\r\n    Player.prototype.tick = function () {\r\n        // do not tick if not playing\r\n        if (this.state != 'playing') {\r\n            return;\r\n        }\r\n\r\n        var time = this.parent.options.autoPlay;\r\n        // default to 3 seconds\r\n        time = typeof time == 'number' ? time : 3000;\r\n        var _this = this;\r\n        // HACK: reset ticks if stopped and started within interval\r\n        this.clear();\r\n        this.timeout = setTimeout(function () {\r\n            _this.parent.next(true);\r\n            _this.tick();\r\n        }, time);\r\n    };\r\n\r\n    Player.prototype.stop = function () {\r\n        this.state = 'stopped';\r\n        this.clear();\r\n        // remove visibility change event\r\n        document.removeEventListener(\r\n            'visibilitychange',\r\n            this.onVisibilityChange\r\n        );\r\n    };\r\n\r\n    Player.prototype.clear = function () {\r\n        clearTimeout(this.timeout);\r\n    };\r\n\r\n    Player.prototype.pause = function () {\r\n        if (this.state == 'playing') {\r\n            this.state = 'paused';\r\n            this.clear();\r\n        }\r\n    };\r\n\r\n    Player.prototype.unpause = function () {\r\n        // re-start play if paused\r\n        if (this.state == 'paused') {\r\n            this.play();\r\n        }\r\n    };\r\n\r\n    // pause if page visibility is hidden, unpause if visible\r\n    Player.prototype.visibilityChange = function () {\r\n        var isPageHidden = document.hidden;\r\n        this[isPageHidden ? 'pause' : 'unpause']();\r\n    };\r\n\r\n    Player.prototype.visibilityPlay = function () {\r\n        this.play();\r\n        document.removeEventListener('visibilitychange', this.onVisibilityPlay);\r\n    };\r\n\r\n    // -------------------------- Flickity -------------------------- //\r\n\r\n    utils.extend(Flickity.defaults, {\r\n        pauseAutoPlayOnHover: true,\r\n    });\r\n\r\n    Flickity.createMethods.push('_createPlayer');\r\n    var proto = Flickity.prototype;\r\n\r\n    proto._createPlayer = function () {\r\n        this.player = new Player(this);\r\n\r\n        this.on('activate', this.activatePlayer);\r\n        this.on('uiChange', this.stopPlayer);\r\n        this.on('pointerDown', this.stopPlayer);\r\n        this.on('deactivate', this.deactivatePlayer);\r\n    };\r\n\r\n    proto.activatePlayer = function () {\r\n        if (!this.options.autoPlay) {\r\n            return;\r\n        }\r\n        this.player.play();\r\n        this.element.addEventListener('mouseenter', this);\r\n    };\r\n\r\n    // Player API, don't hate the ... thanks I know where the door is\r\n\r\n    proto.playPlayer = function () {\r\n        this.player.play();\r\n    };\r\n\r\n    proto.stopPlayer = function () {\r\n        this.player.stop();\r\n    };\r\n\r\n    proto.pausePlayer = function () {\r\n        this.player.pause();\r\n    };\r\n\r\n    proto.unpausePlayer = function () {\r\n        this.player.unpause();\r\n    };\r\n\r\n    proto.deactivatePlayer = function () {\r\n        this.player.stop();\r\n        this.element.removeEventListener('mouseenter', this);\r\n    };\r\n\r\n    // ----- mouseenter/leave ----- //\r\n\r\n    // pause auto-play on hover\r\n    proto.onmouseenter = function () {\r\n        if (!this.options.pauseAutoPlayOnHover) {\r\n            return;\r\n        }\r\n        this.player.pause();\r\n        this.element.addEventListener('mouseleave', this);\r\n    };\r\n\r\n    // resume auto-play on hover off\r\n    proto.onmouseleave = function () {\r\n        this.player.unpause();\r\n        this.element.removeEventListener('mouseleave', this);\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    Flickity.Player = Player;\r\n\r\n    return Flickity;\r\n});\r\n\r\n// add, remove cell\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/add-remove-cell', [\r\n            './flickity',\r\n            'fizzy-ui-utils/utils',\r\n        ], function (Flickity, utils) {\r\n            return factory(window, Flickity, utils);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            window,\r\n            require('./flickity'),\r\n            require('fizzy-ui-utils')\r\n        );\r\n    } else {\r\n        // browser global\r\n        factory(window, window.Flickity, window.fizzyUIUtils);\r\n    }\r\n})(window, function factory(window, Flickity, utils) {\r\n    // append cells to a document fragment\r\n    function getCellsFragment(cells) {\r\n        var fragment = document.createDocumentFragment();\r\n        cells.forEach(function (cell) {\r\n            fragment.appendChild(cell.element);\r\n        });\r\n        return fragment;\r\n    }\r\n\r\n    // -------------------------- add/remove cell prototype -------------------------- //\r\n\r\n    var proto = Flickity.prototype;\r\n\r\n    /**\r\n     * Insert, prepend, or append cells\r\n     * @param {[Element, Array, NodeList]} elems - Elements to insert\r\n     * @param {Integer} index - Zero-based number to insert\r\n     */\r\n    proto.insert = function (elems, index) {\r\n        var cells = this._makeCells(elems);\r\n        if (!cells || !cells.length) {\r\n            return;\r\n        }\r\n        var len = this.cells.length;\r\n        // default to append\r\n        index = index === undefined ? len : index;\r\n        // add cells with document fragment\r\n        var fragment = getCellsFragment(cells);\r\n        // append to slider\r\n        var isAppend = index == len;\r\n        if (isAppend) {\r\n            this.slider.appendChild(fragment);\r\n        } else {\r\n            var insertCellElement = this.cells[index].element;\r\n            this.slider.insertBefore(fragment, insertCellElement);\r\n        }\r\n        // add to this.cells\r\n        if (index === 0) {\r\n            // prepend, add to start\r\n            this.cells = cells.concat(this.cells);\r\n        } else if (isAppend) {\r\n            // append, add to end\r\n            this.cells = this.cells.concat(cells);\r\n        } else {\r\n            // insert in this.cells\r\n            var endCells = this.cells.splice(index, len - index);\r\n            this.cells = this.cells.concat(cells).concat(endCells);\r\n        }\r\n\r\n        this._sizeCells(cells);\r\n        this.cellChange(index, true);\r\n    };\r\n\r\n    proto.append = function (elems) {\r\n        this.insert(elems, this.cells.length);\r\n    };\r\n\r\n    proto.prepend = function (elems) {\r\n        this.insert(elems, 0);\r\n    };\r\n\r\n    /**\r\n     * Remove cells\r\n     * @param {[Element, Array, NodeList]} elems - ELements to remove\r\n     */\r\n    proto.remove = function (elems) {\r\n        var cells = this.getCells(elems);\r\n        if (!cells || !cells.length) {\r\n            return;\r\n        }\r\n\r\n        var minCellIndex = this.cells.length - 1;\r\n        // remove cells from collection & DOM\r\n        cells.forEach(function (cell) {\r\n            cell.remove();\r\n            var index = this.cells.indexOf(cell);\r\n            minCellIndex = Math.min(index, minCellIndex);\r\n            utils.removeFrom(this.cells, cell);\r\n        }, this);\r\n\r\n        this.cellChange(minCellIndex, true);\r\n    };\r\n\r\n    /**\r\n     * logic to be run after a cell's size changes\r\n     * @param {Element} elem - cell's element\r\n     */\r\n    proto.cellSizeChange = function (elem) {\r\n        var cell = this.getCell(elem);\r\n        if (!cell) {\r\n            return;\r\n        }\r\n        cell.getSize();\r\n\r\n        var index = this.cells.indexOf(cell);\r\n        this.cellChange(index);\r\n    };\r\n\r\n    /**\r\n     * logic any time a cell is changed: added, removed, or size changed\r\n     * @param {Integer} changedCellIndex - index of the changed cell, optional\r\n     * @param {Boolean} isPositioningSlider - Positions slider after selection\r\n     */\r\n    proto.cellChange = function (changedCellIndex, isPositioningSlider) {\r\n        var prevSelectedElem = this.selectedElement;\r\n        this._positionCells(changedCellIndex);\r\n        this._getWrapShiftCells();\r\n        this.setGallerySize();\r\n        // update selectedIndex\r\n        // try to maintain position & select previous selected element\r\n        var cell = this.getCell(prevSelectedElem);\r\n        if (cell) {\r\n            this.selectedIndex = this.getCellSlideIndex(cell);\r\n        }\r\n        this.selectedIndex = Math.min(\r\n            this.slides.length - 1,\r\n            this.selectedIndex\r\n        );\r\n\r\n        this.emitEvent('cellChange', [changedCellIndex]);\r\n        // position slider\r\n        this.select(this.selectedIndex);\r\n        // do not position slider after lazy load\r\n        if (isPositioningSlider) {\r\n            this.positionSliderAtSelected();\r\n        }\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    return Flickity;\r\n});\r\n\r\n// lazyload\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/lazyload', [\r\n            './flickity',\r\n            'fizzy-ui-utils/utils',\r\n        ], function (Flickity, utils) {\r\n            return factory(window, Flickity, utils);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            window,\r\n            require('./flickity'),\r\n            require('fizzy-ui-utils')\r\n        );\r\n    } else {\r\n        // browser global\r\n        factory(window, window.Flickity, window.fizzyUIUtils);\r\n    }\r\n})(window, function factory(window, Flickity, utils) {\r\n    'use strict';\r\n\r\n    Flickity.createMethods.push('_createLazyload');\r\n    var proto = Flickity.prototype;\r\n\r\n    proto._createLazyload = function () {\r\n        this.on('select', this.lazyLoad);\r\n    };\r\n\r\n    proto.lazyLoad = function () {\r\n        var lazyLoad = this.options.lazyLoad;\r\n        if (!lazyLoad) {\r\n            return;\r\n        }\r\n        // get adjacent cells, use lazyLoad option for adjacent count\r\n        var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;\r\n        var cellElems = this.getAdjacentCellElements(adjCount);\r\n        // get lazy images in those cells\r\n        var lazyImages = [];\r\n        cellElems.forEach(function (cellElem) {\r\n            var lazyCellImages = getCellLazyImages(cellElem);\r\n            lazyImages = lazyImages.concat(lazyCellImages);\r\n        });\r\n        // load lazy images\r\n        lazyImages.forEach(function (img) {\r\n            new LazyLoader(img, this);\r\n        }, this);\r\n    };\r\n\r\n    function getCellLazyImages(cellElem) {\r\n        // check if cell element is lazy image\r\n        if (cellElem.nodeName == 'IMG') {\r\n            var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');\r\n            var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');\r\n            var srcsetAttr = cellElem.getAttribute(\r\n                'data-flickity-lazyload-srcset'\r\n            );\r\n            if (lazyloadAttr || srcAttr || srcsetAttr) {\r\n                return [cellElem];\r\n            }\r\n        }\r\n        // select lazy images in cell\r\n        var lazySelector =\r\n            'img[data-flickity-lazyload], ' +\r\n            'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';\r\n        var imgs = cellElem.querySelectorAll(lazySelector);\r\n        return utils.makeArray(imgs);\r\n    }\r\n\r\n    // -------------------------- LazyLoader -------------------------- //\r\n\r\n    /**\r\n     * class to handle loading images\r\n     * @param {Image} img - Image element\r\n     * @param {Flickity} flickity - Flickity instance\r\n     */\r\n    function LazyLoader(img, flickity) {\r\n        this.img = img;\r\n        this.flickity = flickity;\r\n        this.load();\r\n    }\r\n\r\n    LazyLoader.prototype.handleEvent = utils.handleEvent;\r\n\r\n    LazyLoader.prototype.load = function () {\r\n        this.img.addEventListener('load', this);\r\n        this.img.addEventListener('error', this);\r\n        // get src & srcset\r\n        var src =\r\n            this.img.getAttribute('data-flickity-lazyload') ||\r\n            this.img.getAttribute('data-flickity-lazyload-src');\r\n        var srcset = this.img.getAttribute('data-flickity-lazyload-srcset');\r\n        // set src & serset\r\n        this.img.src = src;\r\n        if (srcset) {\r\n            this.img.setAttribute('srcset', srcset);\r\n        }\r\n        // remove attr\r\n        this.img.removeAttribute('data-flickity-lazyload');\r\n        this.img.removeAttribute('data-flickity-lazyload-src');\r\n        this.img.removeAttribute('data-flickity-lazyload-srcset');\r\n    };\r\n\r\n    LazyLoader.prototype.onload = function (event) {\r\n        this.complete(event, 'flickity-lazyloaded');\r\n    };\r\n\r\n    LazyLoader.prototype.onerror = function (event) {\r\n        this.complete(event, 'flickity-lazyerror');\r\n    };\r\n\r\n    LazyLoader.prototype.complete = function (event, className) {\r\n        // unbind events\r\n        this.img.removeEventListener('load', this);\r\n        this.img.removeEventListener('error', this);\r\n\r\n        var cell = this.flickity.getParentCell(this.img);\r\n        var cellElem = cell && cell.element;\r\n        this.flickity.cellSizeChange(cellElem);\r\n\r\n        this.img.classList.add(className);\r\n        this.flickity.dispatchEvent('lazyLoad', event, cellElem);\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    Flickity.LazyLoader = LazyLoader;\r\n\r\n    return Flickity;\r\n});\r\n\r\n/*!\r\n * Flickity v2.3.0\r\n * Touch, responsive, flickable carousels\r\n *\r\n * Licensed GPLv3 for open source use\r\n * or Flickity Commercial License for commercial use\r\n *\r\n * https://flickity.metafizzy.co\r\n * Copyright 2015-2021 Metafizzy\r\n */\r\n\r\n(function (window, factory) {\r\n    // universal module definition\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity/js/index', [\r\n            './flickity',\r\n            './drag',\r\n            './prev-next-button',\r\n            './page-dots',\r\n            './player',\r\n            './add-remove-cell',\r\n            './lazyload',\r\n        ], factory);\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            require('./flickity'),\r\n            require('./drag'),\r\n            require('./prev-next-button'),\r\n            require('./page-dots'),\r\n            require('./player'),\r\n            require('./add-remove-cell'),\r\n            require('./lazyload')\r\n        );\r\n    }\r\n})(window, function factory(Flickity) {\r\n    return Flickity;\r\n});\r\n\r\n/*!\r\n * Flickity asNavFor v2.0.2\r\n * enable asNavFor for Flickity\r\n */\r\n\r\n/*jshint browser: true, undef: true, unused: true, strict: true*/\r\n\r\n(function (window, factory) {\r\n    // universal module definition\r\n    /*jshint strict: false */ /*globals define, module, require */\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('flickity-as-nav-for/as-nav-for', [\r\n            'flickity/js/index',\r\n            'fizzy-ui-utils/utils',\r\n        ], factory);\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            require('flickity'),\r\n            require('fizzy-ui-utils')\r\n        );\r\n    } else {\r\n        // browser global\r\n        window.Flickity = factory(window.Flickity, window.fizzyUIUtils);\r\n    }\r\n})(window, function factory(Flickity, utils) {\r\n    // -------------------------- asNavFor prototype -------------------------- //\r\n\r\n    // Flickity.defaults.asNavFor = null;\r\n\r\n    Flickity.createMethods.push('_createAsNavFor');\r\n\r\n    var proto = Flickity.prototype;\r\n\r\n    proto._createAsNavFor = function () {\r\n        this.on('activate', this.activateAsNavFor);\r\n        this.on('deactivate', this.deactivateAsNavFor);\r\n        this.on('destroy', this.destroyAsNavFor);\r\n\r\n        var asNavForOption = this.options.asNavFor;\r\n        if (!asNavForOption) {\r\n            return;\r\n        }\r\n        // HACK do async, give time for other flickity to be initalized\r\n        var _this = this;\r\n        setTimeout(function initNavCompanion() {\r\n            _this.setNavCompanion(asNavForOption);\r\n        });\r\n    };\r\n\r\n    proto.setNavCompanion = function (elem) {\r\n        elem = utils.getQueryElement(elem);\r\n        var companion = Flickity.data(elem);\r\n        // stop if no companion or companion is self\r\n        if (!companion || companion == this) {\r\n            return;\r\n        }\r\n\r\n        this.navCompanion = companion;\r\n        // companion select\r\n        var _this = this;\r\n        this.onNavCompanionSelect = function () {\r\n            _this.navCompanionSelect();\r\n        };\r\n        companion.on('select', this.onNavCompanionSelect);\r\n        // click\r\n        this.on('staticClick', this.onNavStaticClick);\r\n\r\n        this.navCompanionSelect(true);\r\n    };\r\n\r\n    proto.navCompanionSelect = function (isInstant) {\r\n        // wait for companion & selectedCells first. #8\r\n        var companionCells =\r\n            this.navCompanion && this.navCompanion.selectedCells;\r\n        if (!companionCells) {\r\n            return;\r\n        }\r\n        // select slide that matches first cell of slide\r\n        var selectedCell = companionCells[0];\r\n        var firstIndex = this.navCompanion.cells.indexOf(selectedCell);\r\n        var lastIndex = firstIndex + companionCells.length - 1;\r\n        var selectIndex = Math.floor(\r\n            lerp(firstIndex, lastIndex, this.navCompanion.cellAlign)\r\n        );\r\n        this.selectCell(selectIndex, false, isInstant);\r\n        // set nav selected class\r\n        this.removeNavSelectedElements();\r\n        // stop if companion has more cells than this one\r\n        if (selectIndex >= this.cells.length) {\r\n            return;\r\n        }\r\n\r\n        var selectedCells = this.cells.slice(firstIndex, lastIndex + 1);\r\n        this.navSelectedElements = selectedCells.map(function (cell) {\r\n            return cell.element;\r\n        });\r\n        this.changeNavSelectedClass('add');\r\n    };\r\n\r\n    function lerp(a, b, t) {\r\n        return (b - a) * t + a;\r\n    }\r\n\r\n    proto.changeNavSelectedClass = function (method) {\r\n        this.navSelectedElements.forEach(function (navElem) {\r\n            navElem.classList[method]('is-nav-selected');\r\n        });\r\n    };\r\n\r\n    proto.activateAsNavFor = function () {\r\n        this.navCompanionSelect(true);\r\n    };\r\n\r\n    proto.removeNavSelectedElements = function () {\r\n        if (!this.navSelectedElements) {\r\n            return;\r\n        }\r\n        this.changeNavSelectedClass('remove');\r\n        delete this.navSelectedElements;\r\n    };\r\n\r\n    proto.onNavStaticClick = function (event, pointer, cellElement, cellIndex) {\r\n        if (typeof cellIndex == 'number') {\r\n            this.navCompanion.selectCell(cellIndex);\r\n        }\r\n    };\r\n\r\n    proto.deactivateAsNavFor = function () {\r\n        this.removeNavSelectedElements();\r\n    };\r\n\r\n    proto.destroyAsNavFor = function () {\r\n        if (!this.navCompanion) {\r\n            return;\r\n        }\r\n        this.navCompanion.off('select', this.onNavCompanionSelect);\r\n        this.off('staticClick', this.onNavStaticClick);\r\n        delete this.navCompanion;\r\n    };\r\n\r\n    // -----  ----- //\r\n\r\n    return Flickity;\r\n});\r\n\r\n/*!\r\n * imagesLoaded v4.1.4\r\n * JavaScript is all like \"You images are done yet or what?\"\r\n * MIT License\r\n */\r\n\r\n(function (window, factory) {\r\n    'use strict';\r\n    // universal module definition\r\n\r\n    /*global define: false, module: false, require: false */\r\n\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define('imagesloaded/imagesloaded', [\r\n            'ev-emitter/ev-emitter',\r\n        ], function (EvEmitter) {\r\n            return factory(window, EvEmitter);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(window, require('ev-emitter'));\r\n    } else {\r\n        // browser global\r\n        window.imagesLoaded = factory(window, window.EvEmitter);\r\n    }\r\n})(\r\n    typeof window !== 'undefined' ? window : undefined,\r\n\r\n    // --------------------------  factory -------------------------- //\r\n\r\n    function factory(window, EvEmitter) {\r\n        var $ = window.jQuery;\r\n        var console = window.console;\r\n\r\n        // -------------------------- helpers -------------------------- //\r\n\r\n        // extend objects\r\n        function extend(a, b) {\r\n            for (var prop in b) {\r\n                a[prop] = b[prop];\r\n            }\r\n            return a;\r\n        }\r\n\r\n        var arraySlice = Array.prototype.slice;\r\n\r\n        // turn element or nodeList into an array\r\n        function makeArray(obj) {\r\n            if (Array.isArray(obj)) {\r\n                // use object if already an array\r\n                return obj;\r\n            }\r\n\r\n            var isArrayLike =\r\n                typeof obj == 'object' && typeof obj.length == 'number';\r\n            if (isArrayLike) {\r\n                // convert nodeList to array\r\n                return arraySlice.call(obj);\r\n            }\r\n\r\n            // array of single index\r\n            return [obj];\r\n        }\r\n\r\n        // -------------------------- imagesLoaded -------------------------- //\r\n\r\n        /**\r\n         * @param {Array, Element, NodeList, String} elem\r\n         * @param {Object or Function} options - if function, use as callback\r\n         * @param {Function} onAlways - callback function\r\n         */\r\n        function ImagesLoaded(elem, options, onAlways) {\r\n            // coerce ImagesLoaded() without new, to be new ImagesLoaded()\r\n            if (!(this instanceof ImagesLoaded)) {\r\n                return new ImagesLoaded(elem, options, onAlways);\r\n            }\r\n            // use elem as selector string\r\n            var queryElem = elem;\r\n            if (typeof elem == 'string') {\r\n                queryElem = document.querySelectorAll(elem);\r\n            }\r\n            // bail if bad element\r\n            if (!queryElem) {\r\n                console.error(\r\n                    'Bad element for imagesLoaded ' + (queryElem || elem)\r\n                );\r\n                return;\r\n            }\r\n\r\n            this.elements = makeArray(queryElem);\r\n            this.options = extend({}, this.options);\r\n            // shift arguments if no options set\r\n            if (typeof options == 'function') {\r\n                onAlways = options;\r\n            } else {\r\n                extend(this.options, options);\r\n            }\r\n\r\n            if (onAlways) {\r\n                this.on('always', onAlways);\r\n            }\r\n\r\n            this.getImages();\r\n\r\n            if ($) {\r\n                // add jQuery Deferred object\r\n                this.jqDeferred = new $.Deferred();\r\n            }\r\n\r\n            // HACK check async to allow time to bind listeners\r\n            setTimeout(this.check.bind(this));\r\n        }\r\n\r\n        ImagesLoaded.prototype = Object.create(EvEmitter.prototype);\r\n\r\n        ImagesLoaded.prototype.options = {};\r\n\r\n        ImagesLoaded.prototype.getImages = function () {\r\n            this.images = [];\r\n\r\n            // filter & find items if we have an item selector\r\n            this.elements.forEach(this.addElementImages, this);\r\n        };\r\n\r\n        /**\r\n         * @param {Node} element\r\n         */\r\n        ImagesLoaded.prototype.addElementImages = function (elem) {\r\n            // filter siblings\r\n            if (elem.nodeName == 'IMG') {\r\n                this.addImage(elem);\r\n            }\r\n            // get background image on element\r\n            if (this.options.background === true) {\r\n                this.addElementBackgroundImages(elem);\r\n            }\r\n\r\n            // find children\r\n            // no non-element nodes, #143\r\n            var nodeType = elem.nodeType;\r\n            if (!nodeType || !elementNodeTypes[nodeType]) {\r\n                return;\r\n            }\r\n            var childImgs = elem.querySelectorAll('img');\r\n            // concat childElems to filterFound array\r\n            for (var i = 0; i < childImgs.length; i++) {\r\n                var img = childImgs[i];\r\n                this.addImage(img);\r\n            }\r\n\r\n            // get child background images\r\n            if (typeof this.options.background == 'string') {\r\n                var children = elem.querySelectorAll(this.options.background);\r\n                for (i = 0; i < children.length; i++) {\r\n                    var child = children[i];\r\n                    this.addElementBackgroundImages(child);\r\n                }\r\n            }\r\n        };\r\n\r\n        var elementNodeTypes = {\r\n            1: true,\r\n            9: true,\r\n            11: true,\r\n        };\r\n\r\n        ImagesLoaded.prototype.addElementBackgroundImages = function (elem) {\r\n            var style = getComputedStyle(elem);\r\n            if (!style) {\r\n                // Firefox returns null if in a hidden iframe https://bugzil.la/548397\r\n                return;\r\n            }\r\n            // get url inside url(\"...\")\r\n            var reURL = /url\\((['\"])?(.*?)\\1\\)/gi;\r\n            var matches = reURL.exec(style.backgroundImage);\r\n            while (matches !== null) {\r\n                var url = matches && matches[2];\r\n                if (url) {\r\n                    this.addBackground(url, elem);\r\n                }\r\n                matches = reURL.exec(style.backgroundImage);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @param {Image} img\r\n         */\r\n        ImagesLoaded.prototype.addImage = function (img) {\r\n            var loadingImage = new LoadingImage(img);\r\n            this.images.push(loadingImage);\r\n        };\r\n\r\n        ImagesLoaded.prototype.addBackground = function (url, elem) {\r\n            var background = new Background(url, elem);\r\n            this.images.push(background);\r\n        };\r\n\r\n        ImagesLoaded.prototype.check = function () {\r\n            var _this = this;\r\n            this.progressedCount = 0;\r\n            this.hasAnyBroken = false;\r\n            // complete if no images\r\n            if (!this.images.length) {\r\n                this.complete();\r\n                return;\r\n            }\r\n\r\n            function onProgress(image, elem, message) {\r\n                // HACK - Chrome triggers event before object properties have changed. #83\r\n                setTimeout(function () {\r\n                    _this.progress(image, elem, message);\r\n                });\r\n            }\r\n\r\n            this.images.forEach(function (loadingImage) {\r\n                loadingImage.once('progress', onProgress);\r\n                loadingImage.check();\r\n            });\r\n        };\r\n\r\n        ImagesLoaded.prototype.progress = function (image, elem, message) {\r\n            this.progressedCount++;\r\n            this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;\r\n            // progress event\r\n            this.emitEvent('progress', [this, image, elem]);\r\n            if (this.jqDeferred && this.jqDeferred.notify) {\r\n                this.jqDeferred.notify(this, image);\r\n            }\r\n            // check if completed\r\n            if (this.progressedCount == this.images.length) {\r\n                this.complete();\r\n            }\r\n\r\n            if (this.options.debug && console) {\r\n                console.log('progress: ' + message, image, elem);\r\n            }\r\n        };\r\n\r\n        ImagesLoaded.prototype.complete = function () {\r\n            var eventName = this.hasAnyBroken ? 'fail' : 'done';\r\n            this.isComplete = true;\r\n            this.emitEvent(eventName, [this]);\r\n            this.emitEvent('always', [this]);\r\n            if (this.jqDeferred) {\r\n                var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';\r\n                this.jqDeferred[jqMethod](this);\r\n            }\r\n        };\r\n\r\n        // --------------------------  -------------------------- //\r\n\r\n        function LoadingImage(img) {\r\n            this.img = img;\r\n        }\r\n\r\n        LoadingImage.prototype = Object.create(EvEmitter.prototype);\r\n\r\n        LoadingImage.prototype.check = function () {\r\n            // If complete is true and browser supports natural sizes,\r\n            // try to check for image status manually.\r\n            var isComplete = this.getIsImageComplete();\r\n            if (isComplete) {\r\n                // report based on naturalWidth\r\n                this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');\r\n                return;\r\n            }\r\n\r\n            // If none of the checks above matched, simulate loading on detached element.\r\n            this.proxyImage = new Image();\r\n            this.proxyImage.addEventListener('load', this);\r\n            this.proxyImage.addEventListener('error', this);\r\n            // bind to image as well for Firefox. #191\r\n            this.img.addEventListener('load', this);\r\n            this.img.addEventListener('error', this);\r\n            this.proxyImage.src = this.img.src;\r\n        };\r\n\r\n        LoadingImage.prototype.getIsImageComplete = function () {\r\n            // check for non-zero, non-undefined naturalWidth\r\n            // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671\r\n            return this.img.complete && this.img.naturalWidth;\r\n        };\r\n\r\n        LoadingImage.prototype.confirm = function (isLoaded, message) {\r\n            this.isLoaded = isLoaded;\r\n            this.emitEvent('progress', [this, this.img, message]);\r\n        };\r\n\r\n        // ----- events ----- //\r\n\r\n        // trigger specified handler for event type\r\n        LoadingImage.prototype.handleEvent = function (event) {\r\n            var method = 'on' + event.type;\r\n            if (this[method]) {\r\n                this[method](event);\r\n            }\r\n        };\r\n\r\n        LoadingImage.prototype.onload = function () {\r\n            this.confirm(true, 'onload');\r\n            this.unbindEvents();\r\n        };\r\n\r\n        LoadingImage.prototype.onerror = function () {\r\n            this.confirm(false, 'onerror');\r\n            this.unbindEvents();\r\n        };\r\n\r\n        LoadingImage.prototype.unbindEvents = function () {\r\n            this.proxyImage.removeEventListener('load', this);\r\n            this.proxyImage.removeEventListener('error', this);\r\n            this.img.removeEventListener('load', this);\r\n            this.img.removeEventListener('error', this);\r\n        };\r\n\r\n        // -------------------------- Background -------------------------- //\r\n\r\n        function Background(url, element) {\r\n            this.url = url;\r\n            this.element = element;\r\n            this.img = new Image();\r\n        }\r\n\r\n        // inherit LoadingImage prototype\r\n        Background.prototype = Object.create(LoadingImage.prototype);\r\n\r\n        Background.prototype.check = function () {\r\n            this.img.addEventListener('load', this);\r\n            this.img.addEventListener('error', this);\r\n            this.img.src = this.url;\r\n            // check if image is already complete\r\n            var isComplete = this.getIsImageComplete();\r\n            if (isComplete) {\r\n                this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');\r\n                this.unbindEvents();\r\n            }\r\n        };\r\n\r\n        Background.prototype.unbindEvents = function () {\r\n            this.img.removeEventListener('load', this);\r\n            this.img.removeEventListener('error', this);\r\n        };\r\n\r\n        Background.prototype.confirm = function (isLoaded, message) {\r\n            this.isLoaded = isLoaded;\r\n            this.emitEvent('progress', [this, this.element, message]);\r\n        };\r\n\r\n        // -------------------------- jQuery -------------------------- //\r\n\r\n        ImagesLoaded.makeJQueryPlugin = function (jQuery) {\r\n            jQuery = jQuery || window.jQuery;\r\n            if (!jQuery) {\r\n                return;\r\n            }\r\n            // set local variable\r\n            $ = jQuery;\r\n            // $().imagesLoaded()\r\n            $.fn.imagesLoaded = function (options, callback) {\r\n                var instance = new ImagesLoaded(this, options, callback);\r\n                return instance.jqDeferred.promise($(this));\r\n            };\r\n        };\r\n        // try making plugin\r\n        ImagesLoaded.makeJQueryPlugin();\r\n\r\n        // --------------------------  -------------------------- //\r\n\r\n        return ImagesLoaded;\r\n    }\r\n);\r\n\r\n/*!\r\n * Flickity imagesLoaded v2.0.0\r\n * enables imagesLoaded option for Flickity\r\n */\r\n\r\n/*jshint browser: true, strict: true, undef: true, unused: true */\r\n\r\n(function (window, factory) {\r\n    // universal module definition\r\n    /*jshint strict: false */ /*globals define, module, require */\r\n    if (typeof define == 'function' && define.amd) {\r\n        // AMD\r\n        define(['flickity/js/index', 'imagesloaded/imagesloaded'], function (\r\n            Flickity,\r\n            imagesLoaded\r\n        ) {\r\n            return factory(window, Flickity, imagesLoaded);\r\n        });\r\n    } else if (typeof module == 'object' && module.exports) {\r\n        // CommonJS\r\n        module.exports = factory(\r\n            window,\r\n            require('flickity'),\r\n            require('imagesloaded')\r\n        );\r\n    } else {\r\n        // browser global\r\n        window.Flickity = factory(window, window.Flickity, window.imagesLoaded);\r\n    }\r\n})(window, function factory(window, Flickity, imagesLoaded) {\r\n    'use strict';\r\n\r\n    Flickity.createMethods.push('_createImagesLoaded');\r\n\r\n    var proto = Flickity.prototype;\r\n\r\n    proto._createImagesLoaded = function () {\r\n        this.on('activate', this.imagesLoaded);\r\n    };\r\n\r\n    proto.imagesLoaded = function () {\r\n        if (!this.options.imagesLoaded) {\r\n            return;\r\n        }\r\n        var _this = this;\r\n        function onImagesLoadedProgress(instance, image) {\r\n            var cell = _this.getParentCell(image.img);\r\n            _this.cellSizeChange(cell && cell.element);\r\n            if (!_this.options.freeScroll) {\r\n                _this.positionSliderAtSelected();\r\n            }\r\n        }\r\n        imagesLoaded(this.slider).on('progress', onImagesLoadedProgress);\r\n    };\r\n\r\n    return Flickity;\r\n});\r\n\n\n//# sourceURL=webpack://gulp-skeleton/./src/assets/js/modules/flickity-slider.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/assets/js/app.js");
/******/ 	
/******/ })()
;